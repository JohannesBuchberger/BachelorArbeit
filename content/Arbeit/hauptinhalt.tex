\section{Motivation der Gastronomieprozesse}
\subsection{Probleme in der Gastronomie}
Die Gastronomiebranche befindet sich aktuell im Umbruch und dabei mit mehreren Herausforderungen konfrontiert. Ursachen für das sogenannte ''Gastronomiesterben'' sind unter anderem, dass die steigenden Lebensmittelpreise einen günstigen Einkauf schwer machen, sowie die Mehrwertsteuerbelastung und ein zunehmender Personalmangel \citep[vgl.][]{graefe_systemgastronomie_2018} \citep[vgl.][]{graefe_catering_2017}. Besonders stark betroffen sind dabei kleinere Gastronomiebetriebe, die aufgrund ihrer begrenzten Ressourcen und mangelnder Kapazitäten oft nicht in der Lage sind, sich schnell und effektiv anzupassen. \citep[vgl.][]{graefe_themenseite_2024} Dabei machen die kleineren Gastronomiebetriebe einen Großteil der gesamten Gastronomie aus. \citep[vgl.][]{gruner_deutsche_2016}. 

Eine zentrale Problematik für diese Betriebe ist der Fachkräftemangel: Viele Gastronomen stehen vor der Herausforderung, Personal zu finden \citep[vgl.][]{graefe_systemgastronomie_2018}. Gleichzeitig steigt der Druck, sich im Zuge der fortschreitenden Digitalisierung anzupassen, um konkurrenzfähig zu bleiben, wie durch digitale Zahlung \citep[vgl.][]{graefe_themenseite_2024}. Die Kombination dieser beiden Faktoren – Personalmangel und digitale Transformation – bringt kleine Gastronomiebetriebe in eine Lage, in der sie ohne strategische und innovative Lösungsansätze langfristig kaum überlebensfähig sind.

\subsection{Zielsetzung}
\todo{Quellen}
Das Hauptziel dieser Arbeit ist es, basierend auf einem prozessgesteuerten Ansatz durch BPMN Lösungen für die beschriebenen Probleme zu entwickeln.
Insbesondere soll ein universeller Bestellprozess für Selbstbedienungsrestaurants, welcher von verschiedensten Restaurants über Buffet-, Kiosk- und Abholrestaurants hinaus verwendet werden kann, entworfen werden. Dabei soll der Personalbedarf in der Gastronomie minimiert werden und es soll nur ein minimaler Anpassungsaufwand für bestehende Gastronomien sein, diese zu integrieren.
Auch soll der Prozess für die Kundschaft optimiert werden. Etwa durch einen automatischen Zahlungsprozess und eine Vereinfachung der Suche nach Restaurants.
Die Methodik umfasst dabei Gespräche mit den Gastronomien vor Ort, um dabei die Entwicklung und Implementierung von Prozessen mit Abstimmung und Einbezug deren Fachwissens zu gestalten.

\subsection{Aufbau der Arbeit}
\todo{Aufbau der Arbeit erläutern}
Dieses Kapitel gibt einen Überblick über die Struktur der Arbeit und dient dazu, den roten Faden bei der Konzeption und Entwicklung der Anwendung für die Selbstbedienungsprozesse nachvollziehbar zu machen.

%############ AI
%Die vorliegende Bachelorarbeit ist in sechs Kapitel unterteilt. Kapitel 1 führt in die Thematik ein, definiert die Problemstellung und formuliert die Forschungsfrage. Kapitel 2 widmet sich dem theoretischen Rahmen, in dem die relevanten Konzepte und Modelle erläutert werden. Im dritten Kapitel wird die Methodik beschrieben, einschließlich der Datenerhebungs- und Analysemethoden. Die Ergebnisse der Untersuchung werden in Kapitel 4 präsentiert und im darauffolgenden Kapitel 5 kritisch diskutiert. Abschließend fasst Kapitel 6 die zentralen Erkenntnisse zusammen und gibt einen Ausblick auf zukünftige Forschungsperspektiven. Der Aufbau der Arbeit folgt einer logischen Struktur, um die Forschungsfrage schrittweise zu beantworten."
%#################

\section{Konzepte und Technologien des prozessgesteuerten Ansatzes}
\subsection{Der Prozessgesteuerte Ansatz}
Diese Bachelorarbeit zielt darauf ab, eine \ac{PA} gemäß Volker Stiehls Definition zu erstellen. Eine \ac{PA} ist wie folgt definiert.

\begin{quote}
''Prozessgesteuerte Anwendungen sind fachlich orientierte Applikationen, die differenzierende Ende-zu-Ende-Geschäftsprozesse unterstützen, wobei die Prozesse Funktions-, System- und Organisationsgrenzen überschreiten, indem sie die von Plattformen und Anwendungen bereitgestellten Daten und Funktionalitäten wiederverwenden'' \citep[][S. 24]{stiehl_prozessgesteuerte_2013}
\end{quote}

Dem Zitat ist zu entnehmen, dass der Mittelpunkt der Anwendung fachliche Prozesse sind. Damit eine innovative Anwendung entwickelt werden kann, welche diese Anforderungen unterstützt, gibt es den \ac{PDA}. Dieser ist eine Projektabwicklungs- und Implementierungsmethodik, die darauf abzielt, eine prozessgesteuerte Anwendung zu schaffen. Dabei soll der Blick auf die technischen Details zunächst vernachlässigt werden und ein Fokus auf die fachlichen Prozesse gelegt werden. \citep[vgl.][]{stiehl_prozessgesteuerte_2024}

Die Motivation hinter diesem Ansatz liegt darin, Unternehmen – einschließlich solcher in der Gastronomie – zu befähigen, maßgeschneiderte Ende-zu-Ende-Prozesse zu entwickeln, die sowohl vorhandene Daten als auch bestehende Funktionalitäten effizient wiederverwenden, um eine schnelle Implementierung zu ermöglichen. In der Gastronomie kann dies beispielsweise bedeuten, dass Arbeitsabläufe optimiert oder Arbeitskräfte eingespart werden, während dabei die Gäste schneller und individueller bedient werden können, sowie Ressourcenverschwendung minimiert und die Flexibilität bei wechselnden Anforderungen – wie saisonalen Menüs oder besonderen Veranstaltungen – gewährleistet wird.

Zusätzlich ermöglicht der \ac{PDA} eine klare und transparente Prozesssteuerung, was die Effizienz, Überwachung und Anpassungsfähigkeit der Betriebsabläufe erheblich verbessert. Für die Gastronomie bedeutet dies beispielsweise, Bestellprozesse in Echtzeit zu steuern. \citep[vgl.][]{stiehl_prozessgesteuerte_2024}

\paragraphandnewline{Prozessgesteuerte Methodologie}
Die Methodologie, welche den \ac{PDA} realisiert, ist dabei ein Top-down-Ansatz, welcher von den Fachprozessen ausgeht. Mithilfe davon wird der Servicevertrag festgelegt. Dieser gibt an, welche fachlichen Funktionalitäten Drittsysteme bereitzustellen haben, beziehungsweise was von der \ac{PA} bereitgestellt wird. \citep[vgl.][S. 13]{stiehl_prozessgesteuerte_2013}

Anzumerken ist dabei, dass ein Bottom-up-Ansatz bis zuletzt vermieden wird. Dieser würde zuerst die möglicherweise benötigten Services betrachten und sich nicht voll auf die Lösung des fachlichen Problems konzentrieren. \citep[vgl.][S. 53]{stiehl_prozessgesteuerte_2013}

Detaillierter wird beim Top-down-Ansatz ein Problem immer weiter verfeinert, bis sich die Geschäftsobjekte und fachlich benötigten Services herauskristallisieren. Problem dabei ist, dass es zu Services kommen kann, die technisch nicht notwendig oder schwierig zu implementieren sind. \todo{Gegenchecken ob das auch gemacht wurde} Dieser Umstand wird später im Kapitel \fullref{sec:technische_architektur} nochmal aufgegriffen. \citep[vgl.][S. 52ff]{stiehl_prozessgesteuerte_2013}

\paragraphandnewline{Spezifikation von prozessgesteuerten Anwendungen}
\label{par:spezifikation_von_prozessgesteuerten_anwendungen}
Bei der Entwicklung werden dabei die Spezifikationen von prozessgesteuerten Anwendungen, welche einen Top-down-Ansatz abbilden, befolgt.

Hier wird dieser Ansatz grob zusammengefasst erklärt. Die genaue Umsetzung der einzelnen Schritte wird im \fullref{sec:modellierung} zu finden sein.
\begin{enumerate}
    \item Zu Beginn werden Prozessinformationen wie das Problem, das Ziel und vor allem finanzieller Mehrwert beschrieben \citep[vgl.][S. 60]{stiehl_prozessgesteuerte_2013}.
    
    \item \label{enu:item:spezifikation_von_prozessgesteuerten_anwendungen:prozessmodellierung} Dann kommten Informationen wie Startbedingungen ins Spiel. Dazu zählen verschiedene zeitliche Aspekte aber auch technische so wie fachliche Bedingungen. Beispiele dafür sind in etwa, dass der Prozess der regelmäßig jeden Tag um 12:00 Startet, oder einfach nur einmalig alle 4 Jahre zum 29.02. \cite[vgl.][S. 61f]{stiehl_prozessgesteuerte_2013}
    
    Auch stehen hier die Beteiligten Prozessrollen im Vordergrund. Festgelegt wird wer welche Aufgaben beziehungsweise Aktivitäten im Prozess bearbeitet oder dafür in Frage kommt. \citep[vgl.][S. 62]{stiehl_prozessgesteuerte_2013}.
    
    Ebenfalls kommt es hier zur Visualisierung des Prozessflusses. Ziel hierbei ist, dass mindestens der Happy Path des Prozesses bereitgestellt wird. Das bedeutet, dass der Ablauf modelliert wird aber dabei so tun, als ob keine technischen Fehler auftreten können. Fachliche Außnahmesituationen werden hier durchaus behandelt. Auch ob die Aktivitäten vollautomatisch oder durch einen Endnutzer abgewickelt werden müssen ist hier zu modellieren. Die Modellierung dabei durch unter Empfehlung der 5 Schritt Methodik von Silver durchgeführt \cite[vgl.][S. 67-75]{bruce_bpmn_2012}. Die 5 Schritte bestehen im Prinzip aus der
    \begin{enumerate}
        \item Definition des Umfangs des Prozesses
        \item Erstellung eines Happy Path Top-Level Modells
        \item Erweiterung um Ausnahmesituationen
        \item Ausführung durch Unterprozesses
        \item optionalen Ergänzung von Nachrichtenflüssen
    \end{enumerate}
    \cite[vgl.][S. 63ff]{stiehl_prozessgesteuerte_2013}
    
    Anschließend werden die Detailinformationen zusammengetragen. Beispielsweise könnten diese Auskunft darüber geben, welchen Beitrag ein Schritt für den Gesamtprozess leistet, welche Daten er wie nutzt, ob er häufiger ausgeführt wird, ob es Ausnahmen gibt. \cite[vgl.][S. 66f]{stiehl_prozessgesteuerte_2013} 
    
    Zuletzt wird noch der Datenfluss beschrieben. Dabei kann es sich um prozessinterne Daten handeln, also Informationen, die zwischen den einzelnen Aufgaben innerhalb eines Prozesses relevant sind. Es kann sich aber auch um langlebigere Informationen handeln, diese sind dabei entsprechend zu kennzeichnen und werden auch nach dem Prozess noch vorhanden sein. \citep[vgl.][S. 67]{stiehl_prozessgesteuerte_2013}
    
    \item Nun kommt es zum sogenannten ''Modeling beyond the happy path'' \citep{camunda_services_gmbh_modeling_2024}. In diesem Schritt werden die rein fachlichen Ausnahmesituationen genauer betrachtet und gegebenenfalls ergänzt, ob Wiederholungen durchgeführt werden sollen oder sogar ein kompletter Abbruch notwendig ist. \citep[vgl.][S. 67]{stiehl_prozessgesteuerte_2013}
    
    \item Hier sollen zunächst die Geschäftsobjekte, die für jeden Prozessschritt notwendig sind, betrachtet und daraus Relationen gebildet werden. Anschließend wird daraus ein Datenmodell erstellt. \citep[vgl.][S. 69f]{stiehl_prozessgesteuerte_2013}
    
    \item An die Bedürfnisse der Nutzer angepasste Benutzeroberflächen werden entwickelt. Ziel dabei ist es, den Nutzer bestmöglich in seiner Rolle im Prozess zu unterstützen. \citep[vgl.][S. 70f]{stiehl_prozessgesteuerte_2013}
    
    \item Zuletzt werden dann die fachlichen Services definiert. Dabei sind ausschließlich Schnittstellen aus Sicht der prozessgesteuerten Anwendung zu definieren. Ebenfalls kann man hier einen Servicevertrag definieren, der als Zwischenebene zwischen fachlicher Ebene und technischer Ebene dient. \citep[vgl.][S. 72f]{stiehl_prozessgesteuerte_2013}
\end{enumerate}

\clearpage
\subsection{Technologien einer Prozess Engine}
\subsubsection{Grundlagen von BPMN 2.0}
Die für den \ac{PDA} notwendigen Geschäftsprozesse, die auch im vorigen Kapitel schon kurz als fachliche Prozesse angeschnitten wurden, sind eine Folge aus koordinierten Aktivitäten. Diese Geschäftsprozesse benötigen Zeit, verbrauchen Ressourcen und haben unter anderem einen definierten Start und ein Ende \citep[vgl.][S. 1]{gopfert_geschaftsprozessmodellierung_2013}. 

Um diese Prozesse einheitlich modellieren zu können, wie in \fullref{enu:item:spezifikation_von_prozessgesteuerten_anwendungen:prozessmodellierung} beschrieben, wurde \ac{BPMN} 2.0 Standard definiert. Dieser wurde 2011 von \acl{OMG} verabschiedet \citep[vgl.][S. 8]{freund_praxishandbuch_2017}. Im Jahr 2013 wurde \ac{BPMN} 2.0 auch von der \acl{ISO} als Standard veröffentlicht \citep[vgl.][]{iso_isoiec_2013}.

Um ein weiteres Verständnis dieser Bachelorarbeit zu gewährleisten, wird hier ein kurzer Überblick über \ac{BPMN} 2.0 gegeben. Hier wird kein Anspruch auf Vollständigkeit erhoben, da dies den Umfang dieser Bachelorarbeit übersteigen würde. Für detailliertere Informationen zum \ac{BPMN} Standard werden die Bücher \citep{gopfert_geschaftsprozessmodellierung_2013}, \citep{bruce_bpmn_2012} oder \citep{freund_praxishandbuch_2017} empfohlen.

Ein Vorteil bei der Modellierung von Geschäftsprozessen mit \ac{BPMN} ist es, dass man als Werkzeug nicht nur eine rein visuelle Notation an die Hand bekommt, sondern auch die Möglichkeit, ein formales Metamodell der Prozesse zu beschreiben, das auch noch formale Syntax und Symbolsemantik vorgibt. \citep[vgl.][S. 8]{freund_praxishandbuch_2017}. \\
Das Datenformat, das dafür im \ac{BPMN} 2.0-Standard für die Beschreibung der Modelle spezifiziert wurde, ist \ac{XML} \citep[vgl.][]{object_management_group_about_2010}.

\ac{BPMN} bietet viele Freiheiten, und das einzige, das von der \ac{BPMN}-Spezifikation verlangt wird, ist die Vollständigkeit der Diagramme. Daher ist es wichtig, gewisse Qualitätsstandards zu definieren, welche auch für die nachfolgenden Modelle gelten werden. \citep[vgl.][S. 5]{bruce_bpmn_2012}

\begin{itemize}
    \item \textbf{Fehlerfreiheit}; Regeln der \ac{BPMN} Spezifikation werden befolgt.
    \item \textbf{Klarheit}: Diagramm ist für sich selbst eindeutig Verständlich. \label{enu:item:qualitatsstandards:klarheit}
    \item \textbf{Vollständigkeit}: Vollständiger Aktivitätsfluss und Zusammenspiel mit externen Entitäten gegeben.
    \item \textbf{Konsistenz}: Modellierungen unterschiedlicher Menschen unter gleichen Anforderungen führen zum einem sehr ähnlichen Diagramm.
\end{itemize}
\citep[vgl.][S. 5]{bruce_bpmn_2012}

\clearpage
\paragraphandnewline{Relevante \ac{BPMN} Symbole}  
\abbildung{0.85\textwidth}{img/proc:Beispielprozess.png}{fig:tasks}{Beispielprozess (Eigengestaltung)}
Um nachfolgende \ac{BPMN}-Modellierungen einfacher nachvollziehen zu können und den Einstieg und den Zusammenhang zwischen den nachfolgenden Symbolen zu vereinfachen, ist hier ein beispielhaftes \ac{BPMN} Modell dargestellt. Die hier gezeigten Symbole sind dabei nur ein kleines Subset der tatsächlich verfügbaren Symbole und sollen eine mögliche Anordnung zeigen. 

Nachfolgend werden alle vorkommenden \ac{BPMN}-Symbole aufgelistet. Orange gefärbte sind solche, welche von der ausgewählten Process Engine ausgeführt werden können. Alle in schwarz sind allerdings irrelevant, weil diese entsprechend nicht unterstützt werden. Mehr zur Prozess Engine Auswahl in \fullref{sec:process_engine_auswahl}. Ausführlicher werden nicht alle orangen Symbole erklärt, sondern nur die, welche auch später verwendet werden.

Nicht explizit erklärt, aber auch überall verwendet wird der verbindende Weg,  dieser wird ab jetzt Sequenzfluss genannt. Ein Sequenzfluss beschreibt dabei die Logik an, in welcher Reihenfolge der Prozess umgesetzt wird. \citep[vgl.][S. 13]{bruce_englisch_2011} 

\abbildung{0.3\textwidth}{img/spec:pool.png}{fig:pool}{Teilnehmer Pools \citep[][]{camunda_services_gmbh_bpmn_2024}}
''Pools'' gibt es als White-Box-Pools und als Black-Box-Pools. In beiden Varianten werden die im Pool vorhandenen Lanes mit den Namen beschriftet, welche die Aufgaben abarbeitende Geschäftseinheit beziehungsweise Rolle sind. Ein White-Box-Pool ist dabei ein Pool, in dessen Lane ein Geschäftsprozess modelliert ist. Sollten die Lanes eines Pools allerdings leer sein, spricht man von einem Black-Box-Pool. \citep[vgl.][S. 55]{bruce_bpmn_2012}

\clearpage
\abbildung{0.8\textwidth}{img/spec:events.png}{fig:events}{BPMN Ereignisse \citep[][]{camunda_services_gmbh_bpmn_2024}}

In dieser Auflistung sind Symbole vom Typ Multiple und Parallel Multiple nicht vorhanden. Grund dafür ist, dass diese von der ausgewählten Prozess Engine Camunda, wie später im Kapitel \fullref{sec:process_engine_auswahl} näher ausgeführt wird, nicht unterstützt werden.

Nach Silver ist ein \ac{BPMN} Event die Beschreibung dafür, wie ein Prozess auf ein Signal oder einen Hinweis reagiert. Auch beschreibt ein Event, wie der Prozess ein Signal oder einen Hinweis ausgibt, nachdem etwas passiert ist. \citep[vgl.][S. 103]{bruce_bpmn_2012}

Events, welche in einem Prozess das Ausgeben von Signalen oder Hinweisen beschreiben, sind alle, welche unter ''Start'' beziehungsweise unter ''Intermediate''-''Throw'' und ''End'' gelistet sind. Die restlichen ''Intermediate'' Events sind dementsprechend für die Beschreibung, wie der Prozess reagiert, zuständig.

Startet ein Prozess beispielsweise mit einem normalen Start-Event, dieses gibt den Auslöser beziehungsweise den Grund an, warum der Prozess eintritt \citep[vgl.][S. 49]{bruce_bpmn_2012}.

Ein weiteres Ereignis ist das intermediate boundary Escalationevent, auf Deutsch angeheftetes unterbrechendes Eskalationsevent. Der Prozessschritt, an dem dieses Event angeheftet ist, kann abgebrochen werden, solange er aktiv ist. Im Falle eines Abbruchs durch eine Eskalation wird der Sequenzfluss an der Position des Eskalationsevents fortgesetzt, statt dem ursprünglichen Sequenzfluss der Aktivität zu folgen. \citep[vgl.][S. 107]{bruce_englisch_2011}

\abbildung{0.45\textwidth}{img/spec:data_artefacts.png}{fig:data_artefacts}{Data Artefacts \citep[][]{camunda_services_gmbh_bpmn_2024}}
''Data Artefacts'' sind Datenspeicher und stellen Informationseinheiten dar. Diese können entweder in einem extra System hinterlegt werden. Auch innerhalb eines Prozesses können Daten verwaltet werden. Allerdings ist keines der Symbole von der Prozess Engine funktional unterstützt, wie ebenfalls im \fullref{sec:process_engine_auswahl} ausgeführt. Dennoch werden diese gegebenenfalls zu Dokumentationszwecken vereinzelt vorhanden sein. \citep[vgl.][S. 59]{bruce_bpmn_2012}




\abbildung{0.45\textwidth}{img/spec:gateways.png}{fig:gateways}{Gateways \citep[][]{camunda_services_gmbh_bpmn_2024}}
''Gateways'' steuern den Prozessfluss und entscheiden dabei, welche Pfade beschritten werden oder wo diese zusammengeführt werden.

Ein Event Gateway kann dabei nur in Kombination mit Events genutzt werden. Dieses Gateway würde zum Beispiel bei zwei nachfolgenden Nachrichten Events, zuerst den Weg, auch Sequenzfluss genannt, einschlagen, bei dem die Nachricht zuerst zutrifft. \citep[vgl.][S. 46]{bruce_bpmn_2012}

Ein exklusives datenbasiertes Gateway, oder alternativ kürzer XOR-Gateway, kann vereinend als auch teilend sein und dafür zuständig, bereits getroffene Entscheidungen auszuwerten. \citep[vgl.][S. 125f]{bruce_englisch_2011}. 

\clearpage
\abbildung{0.9\textwidth}{img/spec:subprocesses.png}{fig:subprocesses}{Unterprozesse \citep[][]{camunda_services_gmbh_bpmn_2024}}
Wenn ein Prozess sich in mehrere Teilschritte aufteilen lässt, kann man die Aktivitäten dieser einzelnen Teilschritte in ''Unterprozesse'' darstellen. In BPMN wird dabei in verschiedene Arten unterschieden. \citep[vgl.][S. 41]{bruce_bpmn_2012}

Beim eingebetteten Subprozess, welcher der Subprozess links mit dem dünnen Rand auf dem Bild ist, wird der Prozess in derselben Datei modelliert wie der Top-Level-Prozess selbst und dient vor allem dazu, eine bessere Top-down-Ansicht zu schaffen, indem gewisse logisch zusammenhängende Prozessschritte zusammengekapselt werden. Ein Subprozess ist aufgrund der Eigenschaft, innerhalb eines anderen Prozesses modelliert zu sein, ein Prozessschritt, der nicht wiederverwendbar in mehreren Prozessen verwendet werden kann. \citep[vgl.][S. 35, 37f]{bruce_englisch_2011}

Eine andere Variante, Unterprozesse zu nutzen, ist eine Call Activity. Diese ist in der Regel dafür zuständig, einen wiederverwendbaren Unterprozess zu starten. Anzumerken ist dabei, dass der aufgerufene Unterprozess, anders als bei einem eingebetteten Unterprozess, in einer separaten Datei modelliert ist und eher semantisch impliziert, dass der Prozess auch an anderen Stellen, in anderen Prozessen verwendet wird. \citep[vgl.][S. 38f]{bruce_englisch_2011}

\abbildung{0.9\textwidth}{img/spec:tasks.png}{fig:tasks}{Aufgaben, Aktivitäten \citep[][]{camunda_services_gmbh_bpmn_2024}}
Eine Aufgabe, Task oder auch Aktivität ist eine im Prozess geleistete Arbeitseinheit. Eine Aufgabe kann nicht mehr in weitere Elemente unterteilt werden. Der semantische Unterschied zwischen den Aufgaben wird durch das Icon, das die Bezeichnung des Tasktyps anzeigt, dargestellt und zeigt so, welche Bedeutung der Task zukommt. Im Falle einer User Task, auch Benutzer-Task, heißt dies, dass die Aufgabe nur mit Beteiligung oder ganz durch einen Menschen ausgeführt werden muss \citep[vgl.][S. 39ff]{bruce_bpmn_2012}.

\subsubsection{Verwendung von CMMN}

Aufgrund des Fokus dieser Bachelorarbeit auf die strukturierten Prozesse wird \ac{CMMN} nur eine untergeordnete Rolle einnehmen. Entsprechend wird die Erklärung kurz ausfallen, für detailliertere Informationen zu \ac{CMMN} ist ebenfalls \citep{freund_praxishandbuch_2017} zu empfehlen.

\label{par:dreiklang_prozessverbesserungsstandards}
Mit \ac{BPMN} 2.0 wird eigentlich alles angeboten, was für einen Umgang mit Geschäftsprozessen notwendig ist. Trotzdem wurde neben \ac{BPMN} später von der \ac{OMG} auch der \ac{CMMN} Standard veröffentlicht. Laut der \ac{OMG} ist dieser mit dem später veröffentlichten \ac{DMN} Standard Teil des Dreiklangs der Prozessverbesserungsstandards. Die Idee dabei ist, dass \ac{BPMN}, \ac{CMMN} und \ac{DMN} in Kombination verwendet werden können. \citep{object_management_group_case_2016}

\ac{CMMN} soll dabei bei der unstrukturierten Prozessmodellierung verwendet werden. Diese können natürlich auch mit \ac{BPMN} modelliert werden, das kann aber zu mehreren Problemen führen. Einerseits läuft man in die Gefahr, das Ziel der Klarheit, wie definiert in \fullref{enu:item:qualitatsstandards:klarheit}, zu verletzen. Gerade wenn es fachlich notwendig ist, aus einem Gateway 4, 5 ausgehende Wege zu modellieren, und es zusätzlich dann noch notwendig ist, mehrfach zu diesem Gateway zurückzuspringen, kann das Modell schnell unübersichtlich werden \citep[vgl.][S. 9]{freund_praxishandbuch_2017}. \ac{BPMN} bietet dafür zwar ein Ad-Hoc-Symbol an, dieses kann aber auch schnell unübersichtlich werden, sobald beispielsweise für die Wege verschiedenste Regeln notwendig sind. 

Um dem Ziel, Klarheit und Transparenz zu schaffen, nachzukommen, wird \ac{BPMN} für strukturierte Prozesse verwendet und \ac{CMMN} für unstrukturierte Prozesse verwendet. \citep[vgl.][S. 5]{bruce_bpmn_2012}

\subsubsection{\acl{DMN}}

Wie in \fullref{par:dreiklang_prozessverbesserungsstandards} angesprochen wurde, auch \acl{DMN} von der \ac{OMG} veröffentlicht. Der jüngste der Standards und damit der dritte im Bunde ist dabei also \ac{DMN}. Hierbei handelt es sich um einen Standard, der wie \ac{CMMN} und \ac{BPMN} ebenfalls ein in XML beschriebenes formales Metamodell besitzt. Im Gegensatz zu \ac{BPMN} und \ac{CMMN} ist es dabei nicht der Anspruch dieses Standards, Prozesse modellieren zu können. \citep[vgl.][S. 10f]{freund_praxishandbuch_2017} \todo{Stiehl lesen zu DMN} 

\clearpage
\subsection{Die Prozess Engine in einer prozessgesteuerten Anwendung}
\subsubsection{Funktionen einer Prozess Engine}
Um eine \acl{PA} und die damit verbundenen \ac{BPMN}-Modelle zum Ausführen zu bringen, benötigt man zwangsläufig eine Prozess Engine. Damit steht diese als Infrastrukturkomponente verwendete Technologie im Herzen einer \acl{PA}. Da diese so von zentraler Bedeutung ist, ist es wichtig, die Aufgaben neben der Ausführung der Geschäftsprozesse auch kurz abzureißen. \citep[vgl.][]{stiehl_prozessgesteuerte_2024}

Eine Prozess Engine ist eine Softwarekomponente, die zur Automatisierung von Geschäftsprozessen dient. Zur Ausführung müssen Prozessmodelle definiert werden, wie nachfolgend bei \fullref{sec:modellierung} zu sehen ist. \citep[vgl.][]{leymann_definition_2024}

Wie vorher beschrieben, werden \ac{BPMN} Prozesse in \ac{XML} definiert. Diese Modelle können von einer Prozess Engine ausgelesen, interpretiert und zur Ausführung gebracht werden. Damit dies funktionieren kann, müssen diese natürlich alle technischen Details beinhalten, die zur Ausführung notwendig sind. \citep[vgl.][S. 226]{freund_praxishandbuch_2017}

Geschäftsprozesse können teilweise bis zu mehrere Monate oder sogar noch länger laufen. In diesen Zeiträumen kann es durchaus passieren, dass das bestehende Prozessmodell angepasst wird. Dadurch ergibt sich die Anforderung, dass eine Prozess Engine mit mehreren Modellversionen parallel arbeiten kann oder gegebenenfalls die Modelle auch auf ihre neue Version migrieren kann. Das hilft auch dabei, dass jegliche Änderungen in einem \ac{BPMN}-Diagramm und im Lebenszyklus einer Prozess-Instanz nachvollzogen werden können. \citep[vgl.][S. 226]{freund_praxishandbuch_2017}.

Eine weitere Funktion von einer Prozess Engine ist es, vollautomatisch die Metadaten oder auch die konkreten Zustandsdaten, die der Prozess hatte, während der Steuerung von Prozessinstanzen zu sammeln, um Einblicke in die Prozesseffizienz und potenzielle Engpässe zu bieten und eine Nachvollziehbarkeit von einzelnen Prozessen möglich zu machen. Daten, die dabei gesammelt werden, sind z.B. wann eine Aktivität gestartet wurde, wie lange diese gedauert hat, welche Daten als Inputparameter und Outputparameter hinein- bzw. herausgekommen sind. \citep[vgl.][S. 7, 226]{freund_praxishandbuch_2017} \citep[vgl.][]{stiehl_prozessgesteuerte_2024} 

Damit verbunden ist auch die Funktionalität, den aktuellen Status von Prozessinstanzen einzusehen und in das Verhalten einzugreifen, wie zum Beispiel durch das Abbrechen oder Neustarten einer fehlerhaften Instanz \citep[vgl.][S.226]{freund_praxishandbuch_2017}.

Eine Prozess Engine entscheidet darüber, welche Aufgaben und Serviceaufrufe unter welchen Bedingungen stattfinden. Ist also für die Orchestrierung der Services zuständig, indem sie interne oder externe IT-Systeme über Schnittstellen aufruft. \citep[vgl.][S. 6]{freund_praxishandbuch_2017}

\subsubsection{Prozess Engine Auswahl}
\label{sec:process_engine_auswahl}

Aufgrund der Relevanz der Prozess Engine und des Angebots, das herrscht, muss eine gewisse Auswahl getroffen werden. Nach tieferer Recherche wurden mehrere Prozess Engines, die aktuell auf dem Markt sind, gefunden. Eine Liste dieser ist weiter unten unter \fullref{tab:process_engine_list} zu finden. 

\paragraphandnewline{Kriterien}
Um die optimale Prozess Engine auszuwählen, wurde aus den gefundenen auf gewisse Kriterien geachtet. 
\begin{enumerate}
    \item Kostenlos
    \item Technisch robust
    \item Maintenance in der Zukunft
    \item Dokumentation
    \item \acs{BPMN}, \acs{CMMN}, \acs{DMN} Unterstützung
\end{enumerate}

\label{par:kostenlose_process_engines_auswahl}
Aufgrund unseres Einsatzzwecks in der Gastronomie und des geringen Budgets sollen mögliche Kosten für die Zukunft gering gehalten werden. Auch soll ein möglicher zukünftiger kommerzieller Einsatz nicht durch unerwartete Extrakosten für Lizenzen verbunden sein. Daher ist es ein wichtiges Kriterium, dass es kostenlos ist.

Technisch robust bezieht sich dabei auf die Implementierung auf technischer Ebene. Es ist wichtig, dass die Engine wenig Bugs hat und eine zufriedene Nutzerbasis damit auch bei der späteren Implementierung und Ausführung der Prozesse wenig Workarounds oder Ähnliches gefunden werden müssen. Hier ist es auch relevant, auf welchem technischen Stand an sich die Engine ist. Zum Beispiel ob, wenn diese auf Java basiert, sie eine neue Version oder eine alte verwendet. 

Auch dieser Punkt bezieht sich auf die technische Sicht. Maintenance in der Zukunft bezieht sich dabei auf den Zeitraum, in dem die Engine noch Updates bekommt. Das ist insofern relevant, um vor zukünftig auftretenden \acs{CVE} geschützt zu sein  \citep{mitre_cve_2024}.

Um die Engine überhaupt benutzen zu können, ist es unerlässlich, dass eine ausreichende Dokumentation vorhanden ist und es eine gesunde Community gibt.

Da es Prozess Engines gibt, die unter anderem aufgrund der Existenz von \ac{CMMN} nicht den gesamten \ac{BPMN} Standard unterstützen, ist es bei der Auswahl unerlässlich, dass entweder beide Standards oder der \ac{BPMN} Standard vollständig von der ausgewählten Engine ausgeführt werden kann. \ac{DMN} wird voraussichtlich keine relevante Rolle spielen, daher ist der Support eher als optionaler Pluspunkt zu bewerten.

\clearpage
\begin{center}   
\begin{table}[]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \thead{Prozess Engine} & \thead{Webseite} \\
        \hline

        \href{https://github.com/Activiti/Activiti}{Activity} & 
        \href{https://github.com/Activiti/Activiti}{https://github.com/Activiti/Activiti} \\
        \hline

        \href{https://www.processcube.io/}{Process Cube} & 
        \href{https://www.processcube.io/}{https://www.processcube.io/} \\
        \hline
        
        \href{https://www.spiffworkflow.org/}{Spiffworkflow} & 
        \href{https://www.spiffworkflow.org/}{https://www.spiffworkflow.org/} \\
        \hline

        \href{https://github.com/camunda/camunda-bpm-platform}{Camunda 7} & 
        \href{https://github.com/camunda/camunda-bpm-platform}{https://github.com/camunda/camunda-bpm-platform} \\
        \hline

        \href{https://camunda.com/}{Camunda 8} & 
        \href{https://camunda.com/}{https://camunda.com/} \\
        \hline
        
        \href{https://github.com/cibseven/cibseven}{CIB Seven} & 
        \href{https://github.com/cibseven/cibseven}{https://github.com/cibseven/cibseven} \\
        \hline
        
        \href{https://operaton.org/}{Operaton} & 
        \href{https://operaton.org/}{https://operaton.org/} \\
        \hline

        \href{https://www.flowable.com/open-source}{Flowable Opensource} & 
        \href{https://www.flowable.com/open-source}{https://www.flowable.com/open-source} \\
        \hline

        \href{https://www.flowable.com/}{Flowable Enterprise} &
        \href{https://www.flowable.com/}{https://www.flowable.com/} \\
        \hline

        \href{https://kogito.kie.org/}{Kogito} &
        \href{https://kogito.kie.org/}{https://kogito.kie.org/} \\
        \hline
    \end{tabular}
    \caption{Existierende BPMN/CMMN Prozess Engines}
    \label{tab:process_engine_list}
\end{table}
\end{center}
\paragraphandnewline{Bewertung Prozess Engines}
Es gibt durchaus auch andere Prozess Engines, wie JPMN \citep{apache_software_foundation_jbpm_2024}. Diese Liste legt aber keinen Wert auf Vollständigkeit, sondern soll nur dabei helfen, einen Überblick zu gewinnen. Zudem soll der Fokus dieser Bachelorarbeit auf der Konzeption und Implementierung liegen, nicht auf einer allumfassenden Auswahl und Vergleich verschiedener Prozess Engines.

Wie hier in dem Blog von Flowable, siehe \cite{holmes-higgin_digital_2019}, zur Entwicklung von Prozess Engines zu lesen ist, sind die meisten Prozess Engines auf Basis von JPMN und später Activity 5 entstanden. Beispiele hierfür sind z.B. Flowable, Activity, Camunda und wiederum dessen Folks Operaton und CIB Seven. Daher ist davon auszugehen, dass deren technische Robustheit und Support von \ac{BPMN} nicht gravierend unterscheidet.

In den nachfolgenden Ausführungen sind bei den betrachteten Prozess Engines alle kostenpflichtigen Varianten aufgrund der Ausführungen in \fullref{par:kostenlose_process_engines_auswahl} bereits aussortiert. 

Die kostenpflichtigen Prozess Engines sind dabei der Process Cube, Camunda 8 und Flowable Enterprise.

\begin{itemize}
    \item \textbf{Spiffworkflow} bietet einen noch nicht ganz ausreichenden BPMN Standards. So sind 50 von 69 noch nicht unterstützt \citep[vgl.][]{funk_creating_2023}. Zudem ist das Community Ecosystem merkbar klein und technisch noch nicht ganz ausgereift \citep[vgl.][]{spiffworkflow_overview_2024}.

    \item \textbf{Camunda 7} steht vor mehreren Problemen, einerseits fällt der offizielle Support der Prozess Engine für die letzte Version im Jahr 2027 weg \citep[vgl.][]{camunda_services_gmbh_support_2024}. Andererseits ist die Engine auch nicht mehr auf dem neuersten technischen Stand, gerade in Performance Hinsicht \citep[vgl.][]{johnson_why_2023}. Auch kleinere technische Einschränkungen wie kein echtes paralleles Bearbeiten von Tasks sind Malusse von Camunda 7 \citep[vgl.][]{camunda_services_gmbh_camunda_2023}. Bei Camunda 7 gibt es zudem einige nicht unterstützte \ac{BPMN} 2.0 Symbole \citep[vgl.][]{camunda_services_gmbh_bpmn_2024}. 
    
    Davon abgesehen hat Camunda 7 eine relativ große Community und bietet Support für \ac{CMMN} an \citep[vgl.][]{camunda_services_gmbh_cmmn_2024}. Auch \ac{DMN} wird supportet und zudem bietet Camunda 7 einen eigenen Modeller sowie ein eigenes Control Dashboard für aktuelle Prozesse \citep[vgl.][]{camunda_services_gmbh_dmn_2024}. In Bezug auf den wegfallenden Maintainance gibt es Community Anstrengungen wie CIB Seven und Operaton. Diese fokusieren sich jeweils darauf, das weiterhin Support geliefert wird \citep[vgl.][]{cib_open_2024}. Oder das Camunda 7 sogar technisch überholt und neugeschrieben wird \citep[vgl.][]{zoller_operaton_2024}.
    
    \item \textbf{Activity} ist eine neugeschriebene Prozess Engine welche sich auf eine Microservice Architektur fokusiert \citep[vgl.][]{activity_open_2024}. Die Community um Activity ist ebenfalls nicht sonderlich groß und aber es werden eigene Modellierungstools und Überwachungstools angeboten \citep[vgl.][]{activity_activiti_2024}. Von Activity wird zwar \ac{CMMN} nicht unterstützt, die Ad-Hoc Funktionalität ist aber implementiert und kann daher ersetzten verwendet werden \citep[vgl.][]{hyland_activiti_2017}. 

    \item \textbf{Flowable Opensource} ist mit seiner neuen Version 7 auf einem neuen technischen Stand. Außerdem wird der vollständige \ac{BPMN} Standard unterstützt. Auch die Dokumentation ist für die Zwecke dieser Bachelorarbeit ausreichend. Für die Modellierung bietet Flowable zwar \ac{BPMN}, \ac{DMN} und \ac{CMMN} Modellierung über sein Opensource Repository an, allerdings nur bis zur Version 6.8.2. Seit der Version 7 wird Modellierung nur noch über den Online Service von Flowable angeboten. \citep[vgl.][]{flowable_flowable_2024} 
    
    \item \textbf{Kogito} ist ebenfalls eine Opensource Prozess Engine, welche allerdings nicht alle \ac{BPMN} Komponenten unterstützt \citep[vgl.][5.2.2]{kogito_kogito_2024-1}. Auch ist anzumerken, dass aktiv an Kogito weiterentwickelt wird und der \ac{BPMN} Support ausgebaut \citep[vgl.][]{redhat_release_2024}. 
\end{itemize}

\paragraphandnewline{Ergebnis}
Aufgrund der obigen Betrachtung wurde sich für folgendes Modell entschieden. Zur Ausführung und Überwachung der Prozesse wird Camunda 7 verwendet. Bei dem Problem, dass die Wartung wegfällt ab 2027, also dem Auslaufen der aktuellen Camunda 7 LTS Version, wird dies durch CIB Seven oder alternativ Operaton in Angriff genommen. Zur Modellierung wird der Camunda Modeler verwendet und sollte es notwendig sein \ac{CMMN} zu modellieren, wird dies im Flowable Modeler geschehen. 

Dieser Stack bietet den Vorteil, dass eine kostenlose Prozess Engine verwendet wird, welche fast alle notwendigen \ac{BPMN} Komponenten unterstützt und gleichzeitig eine Modellierungs-App und Admin-App, das Cockpit, mitliefert.

\section{Technologische Umsetzung der Prozesse}
\subsection{Technologische Umsetzung der Prozesse}
\subsubsection{ARIS Haus}
\subsubsection{Technische Architektur und Microservices}
\label{sec:technische_architektur}

\subsection{3.2 Verwendete Technologien}
\subsubsection{Asynchrone Kommunikation durch Queuing Systeme}
\subsubsection{Backend Java Frameworks Quarkus und Springboot}
\subsubsection{Frontend Java Frameworks Vue mit Nuxt}

\section{Prozessgestaltung für die Gastronomie}
\subsection{Problemverständnisschärfung durch Kommunikation mit Gastronomen}
\label{sec:problemverstaendnis_gastronomie}
Bei Gesprächen mit Gastronomen in Ingolstadt, hervorzuheben sind dabei Bravo Pizza napoletana und District Five Coffee Roasters - Café.

Erstere sind Gastronomen, die beim Kunden ein Willkommensgefühl auslösen wollen, indem sie diese Kunden immer an der Kasse vor der Küche bestellen lassen. Ziel ist dabei, dass die Kunden den dortigen steinernen Pizzaofen sehen. Das mag erst einmal trivial wirken, aber es fügt dem Ambiente-Gefühl einiges hinzu, zu wissen, wo die Pizza hergestellt wurde.
Relevant für diese Art von Gastronomen ist daher, dass die Kunden dieses Ambiente beim Bestellen mitnehmen können, und lehnen daher eine Online-Bestellung oder auch gerade eine Tisch-Bestellung vom Außenbereich aus ideologischer Sicht ab.

Zweitere hingegen ist ein Café, das aktuell auch die Kunden bei der Kasse bestellen lässt. Das Ziel ist es hier allerdings, Arbeitszeit und -last zu sparen. Die Kunden suchen sich hier einen Tisch und gehen anschließend zum Bestellpunkt, bestellen dabei bei einem der Mitarbeiter. Dabei stehen diese, gerade bei Stoßzeiten, in einer längeren Schlange.

Auch werden bei Änderungen in der Speisekarte für alle Speisekarten die Änderungen auf den entsprechenden Blättern neu ausgedruckt. Was nicht unbedingt viel Flexibilität zeigt, die man auch brauchen kann, wenn an einem Abend gewisse Gerichte nicht mehr verfügbar sind.

Andererseits gibt es auch für den Kunden Verbesserungspotential. Gerade wenn man durch die Stadt geht und Hunger auf gewisse Gerichte hat, wäre es natürlich einfach für den Fußgänger, sich zu jedem Restaurant hinzugeben und sich zu überlegen, ob es die entsprechenden Gerichte gibt. Wenn nur wenige Restaurants in der Umgebung sind, ist das möglich, ebenfalls unter der Voraussetzung, dass diese ihre Speisekarte auch aushängen. Aber auch das kann bei mehreren Gastronomien schnell anstrengend werden.

Es gibt also in der Gastronomie mehrere verschiedene Probleme, bei denen angesetzt werden kann. Einerseits gibt es, wie beschrieben, die Probleme von langen Warteschlangen, hoher Arbeitslast, dem Aufwand bei Speisekartenänderungen und der fehlenden Markttransparenz auf Seiten der speisenden Kundschaft.

Lösungen hierfür wären, dass man alle Probleme hierfür zusammen betrachtet. Klar wäre es zielführend, auf dem Handy einfach kurz zentral auf einer App die umliegenden Speisekarten zu sehen und nach Gerichten zu filtern, welche dazu passen. An der Stelle bietet sich auch viel Potenzial, wie etwa durch eine KI-gestützte Suche und eine mögliche Integration eines One-Click-Buy-Konzeptes \citep[vgl.][]{amazon_oneclick_2025}. Eine ganzheitliche Betrachtung, bei der der Kunde von einer Übersicht über die aktuelle Auslastung und die voraussichtlichen Bedienungszeiträume profitiert, um die zu erwartende Wartezeit bis zur Abholung des Essens im Falle von Selbstbedienung besser einschätzen zu können, und gleichzeitig durch einen Buzzer oder eine Online-Benachrichtigung informiert wird, sobald das Essen fertig ist, würde sowohl den Kunden als auch der Gastronomie durch erhöhte Sichtbarkeit und Effizienz zugutekommen.

Um dies zu erreichen, müssten einheitliche digitalisierte Standardprozesse für die Gastronomie festgelegt werden, die am besten auch die oben genannten Probleme adressieren. Einerseits müsste man hier unterscheiden zwischen Restaurants, die alles mit Bedienungen regeln, und Selbstbedienungsrestaurants, die keine oder nur Bedienstete für eingeschränkte Aufgaben haben.

\subsection{Modellierung der Gastronomieprozesse nach dem \acl{PDA}}
\label{sec:modellierung}
Zu Beginn der Modellierung ist festzuhalten, dass die Idee in dieser Arbeit nicht nur darin besteht, das Verwalten für den Gastronomen und den Arbeitsablauf der Köche und Bedienungen zu vereinfachen, sondern auch im weiteren Schritt für die Kunden.

Die folgenden Kern-Prozesse wurden ebenfalls unter anderem identifiziert. 

\begin{itemize}
    \item Verwaltungsprozess zum Bearbeiten der Speisekarten
    \item Top-Level-Prozess zum Zusammenfassen des Findens und der Bestellung 
    \item Selbstbedienungsrestaurantprozess
\end{itemize}

Auch andere Kern-Prozesse wurden identifiziert, allerdings sind diese nicht Teil dieser Bachelorarbeit, da diese in Kooperation entstanden sind. Die hier zusätzlich aufgelisteten Prozesse werden dabei in der Arbeit von \cite{ott_konzeption_2025} im Kapitel Prozessmodellierung behandelt und werden gegebenenfalls in den nachfolgenden Kapiteln referenziert. 

Umfassend werden also folgende Prozesse nicht in dieser Arbeit behandelt: 
\begin{itemize}
    \item Verwaltungsprozess zum Anlegen der Stamminformationen
    \item Verwaltungsprozess zum Onboarding von Restaurants
    \item Prozess zum Finden von Restaurants
    \item Bedienungsprozess für Bedienrestaurants
\end{itemize}

Ebenfalls wird dieser Stelle nochmal an \fullref{par:spezifikation_von_prozessgesteuerten_anwendungen} verwiesen, hier wurde das nachfolgende Vorgehen bereits grundlegend erklärt und wird nun für jeden der folgenden Prozesse angewendet.

% =================================
% = Main Process
% =================================
\subsubsection{Speisehauptprozess}
Damit die einzelnen Prozesse miteinander funktionieren, ist es notwendig, dass die Koordination zwischen den verschiedenen Kern-Prozessen hergestellt wird. Die Aufgabe dieses Top-Level-Prozesses ist es entsprechend, die verschiedenen Teilprozesse zu verheiraten. Die Verwaltungsprozesse werden dabei außen vor gelassen, weil diese einem anderen fachlichen Kontext dienen. 

\begin{itemize}
    \item \textbf{Prozess zum Finden von Restaurants}: Dieser Prozess umfasst das Auffinden von nahegelegenden Restaurants und deren Speisekarte. Ob diese bereits einen Account bei uns erstellt haben wird hier identifiziert sowie eine Auswahl des Endnutzers wird hier erwartet.
    
    \item \textbf{Selbstbedienungsrestaurantprozess}: Dieser Prozess umfasst Bestellung, Bezahlung, Kochvorgang und Abholung des Essens vom Kunden.
    
    \item \textbf{Bedienungsprozess für Bedienrestaurants}: Hier wird die Bestellung, Bezahlung, Kochvorgang, Tischverwaltung und Kochvorgang sowie Abholung des Essens geregelt. 
\end{itemize}

Die Randbedingungen um diesen Prozess sind relativ lose ohne Einschränkungen gestaltet. Gestartet werden kann dieser Prozess zu jedem beliebigen Zeitpunkt und auch sonst gibt es kaum Einschränkungen. Ziel ist es ja, dass dieser Prozess möglichst zugänglich ist.

\paragraphandnewline{Beteiligte Prozessrollen}
Ausgangsperson, welche diesen Prozess startet, ist der hungernde Kunde. Dieser sucht sich ein Restaurant, und hierbei kommen dann gegebenenfalls Köche, Küchengehilfen und gegebenenfalls Bedienungen ins Spiel. 

\clearpage
\paragraphandnewline{Visualisierung des Prozessflusses}
\abbildung{1\textwidth}{img/proc:SpeiseMain.png}{iref:SpeiseMain}{Top-Level-Prozess für die Speisen}

In der Modellierung des Prozesses folgen wir zunächst dem Happy Path, dabei ist Folgendes beim Startereignis zu erkennen: in diesem Fall, dass ein hungriger Kunde vorhanden ist.

Der Sequenzfluss läuft daraufhin in ein zusammenführendes XOR-Gateway, welches bei der ausschließlichen Betrachtung des Happy Paths noch nicht relevant ist und daher fürs Erste ignoriert werden kann. Wie zu sehen ist, landet der Sequenzfluss nun in einer Call Activity. Diese Stelle im Prozess kennzeichnet somit den Start des Restaurantfindungsprozesses.

Die Gründe, warum hierbei auf eine Call Activity und nicht auf einen eingebetteten Subprozess zurückgegriffen wurde, sind dabei wie folgt. Anders als in einer Call Activity ist es in eingebetteten Subprozessen nicht möglich, einen Pool mit Lanes zu modellieren. Ein eingebetteter Subprozess ist nur ein ausführlicher Teilschritt, daher ist es auch nicht vorgesehen. Ein weiterer Vorteil ist, dass dabei eine parallele Entwicklung vereinfacht wird, da jeder an seinem Prozess feilen kann, ohne gegebenenfalls den Fortschritt des jeweils anderen zu beeinflussen. Um sicherzustellen, dass das Ganze funktioniert, werden bereits im Vorherein Schnittstellen zwischen den Prozessen definiert. Also, was der Unterprozess dem Top-Level-Prozess zurückgeben muss, beziehungsweise welche Eingangsparameter dieser benötigt. Was bei einem weiteren Blick auf das Prozessmodell ebenfalls auffällt, ist, dass gewisse Call Activities rot markiert sind. Die rote Markierung ist da, um hervorzuheben, dass diese Prozessschritte nicht Teil dieser Arbeit sind und daher nicht oder nur oberflächlich behandelt werden.

Nach Abschluss dieses Unterprozesses wird automatisch, programmatisch durch eine Service Task entschieden, ob das resultierende ausgewählte Restaurant ein Selbstbedienungsrestaurant ist oder ein Restaurant, welches Bedienungen beschäftigt. Der Selbstbedienungsrestaurant-Unterprozess wird aufgrund seiner Relevanz und Komplexität im nachfolgenden \fullref{sec:selbstbedienungsrestaurantunterprozess} behandelt.


Das darauf folgende XOR-Gateway teilt den Sequenzfluss abhängig vom Ergebnis der Service Task in Richtung des Selbstbedienungsrestaurant Prozess oder des Bedienungsrestaurant Prozess auf. Diese werden aus denselben Gründen wie beim vorigen Subprozess als Call Activity gestartet. Zum Schluss, nachdem der jeweilige Restaurant-Unterprozess abgeschlossen wurde, endet der Top-Level-Prozess dann mit einem nicht mehr hungrigen Kunden.

Nachdem der Beleuchtung des Happy Paths, kommt es nun zur Ausnahmebehandlung. Hierbei ist auf die beiden angehefteten Events, welche bei den Call Activities anhängen, zu verweisen. Beide sollen das Ausnahmeszenario, bei dem ein Nutzer sich doch noch für ein anderes Restaurant umentscheidet, nachspielen. Diese beiden angehefteten unterbrechenden Eskalationsevents führen entsprechend den Kunden wieder zurück bis vor den Restaurantfindungsprozess, weil dieser Prozess auch zur Aufgabe hat, dass der Kunde sein Restaurant auswählt.

Auf wie in \fullref{par:spezifikation_von_prozessgesteuerten_anwendungen} beschrieben, wird auf die optionale Ergänzung von Nachrichtenflüssen an dieser Stelle vorerst verzichtet, um die Komplexität des Prozesses zu reduzieren und weil es keine wirklichen Schnittstellen zu externen Systemen gibt.

\paragraphandnewline{Beschreibung des Datenflusses}
Entsprechend dem ARIS-Modell wurden die Organisationssicht, also wer was macht, die Funktionssicht, also was gemacht wird, und die Steuerungssicht, also der Ablauf, beantwortet. Jetzt fehlt nur noch die Datensicht, also womit was gemacht wird. \citep[vgl.][]{light_aris_2025}

Um zu dieser zu kommen, werden zunächst die Geschäftsobjekte betrachtet, die in diesem Prozess von Relevanz sind. Diese sind hier nur der Kunde und ein Restaurant.

Diese Geschäftsobjekte werden konkret, nachdem der Restaurantfindungsprozess durchgelaufen ist, herausgegeben. Hervorgehoben im Diagramm werden diese durch das Data Object Symbol. Einerseits soll das ausgewählte Restaurant und welcher Kunde für die Bestellung verantwortlich ist, dem Top-Level-Prozess zur Verfügung gestellt werden. Die Information darüber, wer dieser Kunde ist, ist optional, weil ein Kunde, der noch keinen Account hat, an dieser Stelle noch nicht blockiert werden soll. Wie der Datenfluss zeigt, werden diese beiden Geschäftsobjekte dann von den beiden Restaurantprozessen genutzt.

Um nicht jedes Mal Anpassungen im Laufe der nächsten Prozessbeschreibungen beim Datenmodell durchführen zu müssen, wird ein einheitliches Datenmodell mit der Aufschlüsselung der Geschäftsobjekte für alle Prozesse in \fullref{sec:datenmodell} zu finden sein.

% =================================
% = Selbstbedienungsrestaurantprozess
% =================================
\subsubsection{Essensbestellprozess für Selbstbedienungsrestaurants}
\label{sec:selbstbedienungsrestaurantunterprozess}
Um die in \fullref{sec:problemverstaendnis_gastronomie} beschriebenen Probleme von langen Warteschlangen und hoher Arbeitslast, welche unter anderem durch die Gebundenheit von Personal durch die Bestellungsaufnahme entstehen, zu reduzieren, wird dieser Prozess modelliert. Hierbei sind die einzelnen Teilschritte der Bestellung, Bezahlung, des Kochvorgangs und Abholung des Essens von besonderer Bedeutung, weil dies die primären Schritte sind, die den Prozess ausmachen.

Gerade bei der Bezahlung, beziehungsweise wann diese notwendig ist, soll viel Freiraum lassen, damit der Gastronom dies für sich passend gestalten kann.

Um den Prozess zu starten, ist es unbedingt notwendig, das Geschäftsobjekt über das Restaurant, welches im Zentrum hineingeben wird, anzugeben. Andernfalls soll der Prozess jederzeit startbar sein und hat daher keine weiteren Einschränkungen.

\paragraphandnewline{Beteiligte Prozessrollen}
Die relevanten Rollen hierbei sind der speisende Kunde und das Restaurant.
Während die meisten Aufgaben, gerade Bezahlung, Bestellung und die Abholung des Essens, fast ausschließlich, bis auf wenige Ausnahmen, vom Kunden zu erledigen sind, ist der Kochvorgang vollständig auf Seiten des Restaurants durchzuführen.

\paragraphandnewline{Visualisierung des Prozessflusses}
\abbildung{1\textwidth}{img/proc:Selbstbedienungsrestaurant.png}{iref:SpeiseMain}{Toplevel-Prozess für die Speisen}

Auch hier wird zunächst wieder ausschließlich der Happy Path betrachtet. Direkt zu Beginn des Prozesses wird über eine Benutzer-Task vom Kunden verlangt, dass er eine Bestellung aufgibt.

Der Sequenzfluss zeigt anschließend in einen ''Zahlungsprozess''. Im ''Zahlungsprozess'' wird zunächst geprüft, ob es vom Gastronom gewünscht ist, dass hier schon eine Zahlung durchgeführt werden soll. Falls ja, würde hier gezahlt werden, falls nein, würde hier nicht gezahlt werden, sondern erst zu einer späteren Stelle. Nachdem der Unterprozess abgeschlossen wurde, wird hier der Unterprozess ''Bestellungsaufgabeprozess'' gestartet. Dieser ist zunächst für das konkrete Abschicken der Bestellung zuständig.

Weiter geht es jetzt mit dem ''Zubereitungsprozess'' welcher der Küche die Bestellung übermitteln soll. \todo{rollen wechsel}

\paragraphandnewline{Detailinformationen zu den Prozessschritten}


\paragraphandnewline{Beschreibung des Prozesskontexts}

% =================================
% = Main Process
% =================================
\subsubsection{Verwaltungsprozess zum Speisekarten Editieren}
Der Prozess zum Speisekarten Editieren kann prinzipiell jederzeit gestartet werden. Es gibt keine wirklichen Bedingungen, da die Idee ist, dass der Einstieg sehr einfach ist. Daher soll es möglich sein, dass jeder selbst ohne Account oder Ähnliches direkt in die Erstellung, welche das Editieren umfasst, springen kann. Sollte bereits eine Speisekarte existieren, ist eine Prüfung eines Accounts notwendig.

In Bezug auf Randbedingungen, welche hierbei zu betrachten sind, sind folgende relevant. Der Prozess sollte innerhalb von 24 Stunden abgeschlossen werden, andernfalls wird angenommen, dass kein Interesse mehr besteht. Der Prozess soll dabei auf mehrere Arten enden können, einerseits durch ein Zwischenspeichern der Änderungen oder dem Veröffentlichen der Änderungen, andererseits durch das manuelle Abbrechen, Verwerfen der Änderungen, das der Standardfall wäre, sollte die ''Time To Life'' überschritten werden.

\paragraphandnewline{Beteiligte Prozessrollen}
Die Person, die in diesem Prozess konkret Aufgaben übernehmen kann, ist diejenige, die für die Führung der Speisekarte zuständig ist.

\clearpage
\paragraphandnewline{Visualisierung des Prozessflusses}

\paragraphandnewline{Detailinformationen zu den Prozessschritten}
Hierbei wird sich an der 


\paragraphandnewline{Beschreibung des Prozesskontexts}
Was passiert mit den Prozessdaten,  Klassendiagramm!


\subsection{Datenmodell}
\label{sec:datenmodell}
Hier is das Datenmodell


% ================
\clearpage
\abbildung{0.3\textwidth}{img/CallAct-LoginProc-Empty.png}{iref-call-activity-login-process-empty}{Konfigurationsfeld für die Call Activity}

Im Konfigurationsfeld zur Call Activity gibt es die beiden Kategorien ''General'' und ''Called element''. Es gibt auch noch weitere, aber die werden später angeschaut. 

Die ''General'' Kategorie. In dieser hat der ''Name'' Syntaktisch keine Bedeutung und dient legentlich der Lesbarkeit. Die ''ID'' wiederum dient der eindeutigen Identifizerung der Aktivität und muss daher auch einzigartig sein.
x§
Die ''Called element'' Kategorie gibt es nur in der Call Activity. Hier kann man folgende Einstellungen treffen.

\begin{itemize}
    \item ''Type'': Hier kann man auswählen ob man lieber ein \acs{BPMN} oder \acs{CMMN} ausführen will. \acs{CMMN} ist eine eigene Notation, die sich gut als Ergänzung zu \acs{BPMN} eignet. Da sich im Prinzip ein CMMN zu einem gewissen grad auch als Ad hoc Prozess darstellbar ist, wird um den Umfang im Ramen der Bachelorarbeit nicht zu überschreiten auf \acs{CMMN} verzichtet. Ad-Hoc Subprocess nicht supported daher CMMN
    https://docs.camunda.org/manual/7.22/reference/bpmn20/
    % https://www.hsbi.de/multimedia/Fachbereiche/Wirtschaft/Forschung/Arbeitsgruppe+Proze%C3%9Fmanagement/Konferenzpapiere/A_+Zensen_+J_+K%C3%BCster_+A+Comparison+of+Flexible+BPMN+and+CMMN+in+Practice_+in+Proc_+EDOC+2018_+S_+105_114_+IEEE+Computer+Society_+2018-p-126478.pdf?download=1
    wird auch nicht mehr supported - siehe
    \item ''Called element'': Dieses Attribut enthält den ''process definition key''. Der Key ist der selbe, der in der Prozessmodellierung als ID vergeben wird. Dies wird wird im 
    Camunda Modeler als Vermerk angezeigt. Dieser Key muss dabei auf den aufzurufenden Prozess zeigen. Siehe nachfolgend
    % https://docs.camunda.org/manual/7.22/reference/bpmn20/subprocesses/call-activity/
\end{itemize}
\clearpage
\abbildung{0.5\textwidth}{img/ProcessId-Equals-ProcessDefinitionKey}{iref-call-activity-process-id}{Vermerk das Process Id zu process definition key gemapped wird}


    latest: always call the latest process definition version (which is also the default behaviour if the attribute isn’t defined)
    deployment: if called process definition is part of the same deployment as the calling process definition, use the version from deployment
    version: call a fixed version of the process definition, in this case calledElementVersion is required. The version number can either be specified in the BPMN XML or returned by an expression (see custom extensions)
    versionTag: call a fixed version tag of the process definition, in this case calledElementVersionTag is required. The version tag can either be specified in the BPMN XML or returned by an expression (see custom extensions)


\section{expression}
https://juel.sourceforge.net/
https://docs.camunda.org/manual/7.22/user-guide/process-engine/expression-language/

\section{history cleanup ttl}
https://docs.camunda.org/manual/latest/user-guide/process-engine/history/history-cleanup/

https://docs.camunda.org/manual/latest/user-guide/process-engine/history/

https://en.wikipedia.org/wiki/ISO_8601#Durations

\subsubsection{Selbstbedinungsprozessmodellierung}


\section{Ausblick der praktischen Anwendung}


 
