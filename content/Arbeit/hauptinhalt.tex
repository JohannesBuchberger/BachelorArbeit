\section{Motivation der Gastronomieprozesse}
\label{sec:motivation_gastronomie}
\subsection{Probleme in der Gastronomie}
Die Gastronomiebranche befindet sich aktuell im Umbruch und dabei mit mehreren Herausforderungen konfrontiert. Ursachen für das sogenannte ''Gastronomiesterben'' sind unter anderem, dass die steigenden Lebensmittelpreise einen günstigen Einkauf schwer machen, sowie die Mehrwertsteuerbelastung und ein zunehmender Personalmangel \citep[vgl.][]{graefe_systemgastronomie_2018} \citep[vgl.][]{graefe_catering_2017}. Besonders stark betroffen sind dabei kleinere Gastronomiebetriebe, die aufgrund ihrer begrenzten Ressourcen und mangelnder Kapazitäten oft nicht in der Lage sind, sich schnell und effektiv anzupassen. \citep[vgl.][]{graefe_themenseite_2024} Dabei machen die kleineren Gastronomiebetriebe einen Großteil der gesamten Gastronomie aus. \citep[vgl.][]{gruner_deutsche_2016}. 

Eine zentrale Problematik für diese Betriebe ist der Fachkräftemangel: Viele Gastronomen stehen vor der Herausforderung, Personal zu finden \citep[vgl.][]{graefe_systemgastronomie_2018}. Gleichzeitig steigt der Druck, sich im Zuge der fortschreitenden Digitalisierung anzupassen, um konkurrenzfähig zu bleiben, wie durch digitale Zahlung \citep[vgl.][]{graefe_themenseite_2024}. Die Kombination dieser beiden Faktoren – Personalmangel und digitale Transformation – bringt kleine Gastronomiebetriebe in eine Lage, in der sie ohne strategische und innovative Lösungsansätze langfristig kaum überlebensfähig sind.

\subsection{Zielsetzung}
\todo{Quellen}
Das Hauptziel dieser Arbeit ist es, basierend auf einem prozessgesteuerten Ansatz durch BPMN Lösungen für die beschriebenen Probleme zu entwickeln.
Insbesondere soll ein universeller Bestellprozess für Selbstbedienungsrestaurants, welcher von verschiedensten Restaurants über Buffet-, Kiosk- und Abholrestaurants hinaus verwendet werden kann, entworfen werden. Dabei soll der Personalbedarf in der Gastronomie minimiert werden und es soll nur ein minimaler Anpassungsaufwand für bestehende Gastronomien sein, diese zu integrieren.
Auch soll der Prozess für die Kundschaft optimiert werden. Etwa durch einen automatischen Zahlungsprozess und eine Vereinfachung der Suche nach Restaurants.
Die Methodik umfasst dabei Gespräche mit den Gastronomien vor Ort, um dabei die Entwicklung und Implementierung von Prozessen mit Abstimmung und Einbezug deren Fachwissens zu gestalten.

\subsection{Aufbau der Arbeit}
Dieses Kapitel gibt einen Überblick über die Struktur der Arbeit und dient dazu, den roten Faden bei der Konzeption und Entwicklung der Anwendung für die Selbstbedienungsprozesse nachvollziehbar zu machen.

Die vorliegende Bachelorarbeit ist in 5 Kapitel unterteilt. Hier im \autoref{sec:motivation_gastronomie} wurde wesentlich in die Thematik eingeführt und der Umfang dieser Arbeit formuliert. \autoref{sec:konzepte_tech_pda} widmet sich den vielen relevanten Konzepten, Methoden, Technologien und Modellen, die für das weitere Verständnis der Bachelorarbeit notwendig sind. Ebenfalls werden hier bereits die Entscheidungen getroffen, warum welche grundlegende Technologie für die Ausführung der Bachelorarbeit verwendet wird.

Im \autoref{sec:prozesse_gastronomie} wird schließlich eine genauere Problemverständnisschärfung durchgeführt. Daraus werden dann durch die im  \autoref{sec:konzepte_tech_pda} erklärten Methoden Prozesse abgeleitet, welche anschließend ausmodelliert erklärt werden.

Technische Details zu der durch die im \autoref{sec:prozesse_gastronomie} entstandenen Prozesse werden im \autoref{sec:technologie_prozesse} genauer erläutert. Darunter fällt dann Datenmodellierung sowie die Architektur des Systems und deren Komponenten.

Zum Schluss der Arbeit folgt im \autoref{sec:zukunft} ein Ausblick auf zukünftige Entwicklungen, die sich daraus ergeben können.

\clearpage
\section{Konzepte und Technologien des prozessgesteuerten Ansatzes}
\label{sec:konzepte_tech_pda}
\subsection{Der Prozessgesteuerte Ansatz}
Diese Bachelorarbeit zielt darauf ab, eine \ac{PA} gemäß Volker Stiehls Definition zu erstellen. Eine \ac{PA} ist wie folgt definiert.

\begin{quote}
''Prozessgesteuerte Anwendungen sind fachlich orientierte Applikationen, die differenzierende Ende-zu-Ende-Geschäftsprozesse unterstützen, wobei die Prozesse Funktions-, System- und Organisationsgrenzen überschreiten, indem sie die von Plattformen und Anwendungen bereitgestellten Daten und Funktionalitäten wiederverwenden'' \citep[][S. 24]{stiehl_prozessgesteuerte_2013}
\end{quote}

Dem Zitat ist zu entnehmen, dass der Mittelpunkt der Anwendung fachliche Prozesse sind. Damit eine innovative Anwendung entwickelt werden kann, welche diese Anforderungen unterstützt, gibt es den \ac{PDA}. Dieser ist eine Projektabwicklungs- und Implementierungsmethodik, die darauf abzielt, eine prozessgesteuerte Anwendung zu schaffen. Dabei soll der Blick auf die technischen Details zunächst vernachlässigt werden und ein Fokus auf die fachlichen Prozesse gelegt werden. \citep[vgl.][]{stiehl_prozessgesteuerte_2024}

Die Motivation hinter diesem Ansatz liegt darin, Unternehmen – einschließlich solcher in der Gastronomie – zu befähigen, maßgeschneiderte Ende-zu-Ende-Prozesse zu entwickeln, die sowohl vorhandene Daten als auch bestehende Funktionalitäten effizient wiederverwenden, um eine schnelle Implementierung zu ermöglichen. In der Gastronomie kann dies beispielsweise bedeuten, dass Arbeitsabläufe optimiert oder Arbeitskräfte eingespart werden, während dabei die Gäste schneller und individueller bedient werden können, sowie Ressourcenverschwendung minimiert und die Flexibilität bei wechselnden Anforderungen – wie saisonalen Menüs oder besonderen Veranstaltungen – gewährleistet wird.

Zusätzlich ermöglicht der \ac{PDA} eine klare und transparente Prozesssteuerung, was die Effizienz, Überwachung und Anpassungsfähigkeit der Betriebsabläufe erheblich verbessert. Für die Gastronomie bedeutet dies beispielsweise, Bestellprozesse in Echtzeit zu steuern. \citep[vgl.][]{stiehl_prozessgesteuerte_2024}

\paragraphandnewline{Prozessgesteuerte Methodologie}
Die Methodologie, welche den \ac{PDA} realisiert, ist dabei ein Top-down-Ansatz, welcher von den Fachprozessen ausgeht. Mithilfe davon wird der Servicevertrag festgelegt. Dieser gibt an, welche fachlichen Funktionalitäten Drittsysteme bereitzustellen haben, beziehungsweise was von der \ac{PA} bereitgestellt wird. \citep[vgl.][S. 13]{stiehl_prozessgesteuerte_2013}

Anzumerken ist dabei, dass ein Bottom-up-Ansatz bis zuletzt vermieden wird. Dieser würde zuerst die möglicherweise benötigten Services betrachten und sich nicht voll auf die Lösung des fachlichen Problems konzentrieren. \citep[vgl.][S. 53]{stiehl_prozessgesteuerte_2013}

Detaillierter wird beim Top-down-Ansatz ein Problem immer weiter verfeinert, bis sich die Geschäftsobjekte und fachlich benötigten Services herauskristallisieren. Das Problem dabei ist, dass es zu Services kommen kann, die technisch nicht notwendig oder schwierig zu implementieren sind. Darum wird das durch einen technischen Blick nach dem Definieren der Services ergänzt, um genau das zu verhindern. \citep[vgl.][S. 52ff]{stiehl_prozessgesteuerte_2013}.

\paragraphandnewline{Spezifikation von prozessgesteuerten Anwendungen}
\label{par:spezifikation_von_prozessgesteuerten_anwendungen}
Bei der Entwicklung werden dabei die Spezifikationen von prozessgesteuerten Anwendungen, welche einen Top-down-Ansatz abbilden, befolgt.

Hier wird dieser Ansatz grob zusammengefasst erklärt. Die genaue Umsetzung der einzelnen Schritte wird im \fullref{sec:modellierung} zu finden sein.
\begin{enumerate}
    \item Zu Beginn werden Prozessinformationen wie das Problem, das Ziel und vor allem finanzieller Mehrwert beschrieben \citep[vgl.][S. 60]{stiehl_prozessgesteuerte_2013}.
    
    \item \label{enu:item:spezifikation_von_prozessgesteuerten_anwendungen:prozessmodellierung} Dann kommten Informationen wie Startbedingungen ins Spiel. Dazu zählen verschiedene zeitliche Aspekte aber auch technische so wie fachliche Bedingungen. Beispiele dafür sind in etwa, dass der Prozess der regelmäßig jeden Tag um 12:00 Startet, oder einfach nur einmalig alle 4 Jahre zum 29.02. \cite[vgl.][S. 61f]{stiehl_prozessgesteuerte_2013}
    
    Auch stehen hier die Beteiligten Prozessrollen im Vordergrund. Festgelegt wird wer welche Aufgaben beziehungsweise Aktivitäten im Prozess bearbeitet oder dafür in Frage kommt. \citep[vgl.][S. 62]{stiehl_prozessgesteuerte_2013}.
    
    Ebenfalls kommt es hier zur Visualisierung des Prozessflusses. Ziel hierbei ist, dass mindestens der Happy Path des Prozesses bereitgestellt wird. Das bedeutet, dass der Ablauf modelliert wird aber dabei so tun, als ob keine technischen Fehler auftreten können. Fachliche Außnahmesituationen werden hier durchaus behandelt. Auch ob die Aktivitäten vollautomatisch oder durch einen Endnutzer abgewickelt werden müssen ist hier zu modellieren. Die Modellierung dabei durch unter Empfehlung der 5 Schritt Methodik von Silver durchgeführt \cite[vgl.][S. 67-75]{bruce_bpmn_2012}. Die 5 Schritte bestehen im Prinzip aus der
    \begin{enumerate}
        \item Definition des Umfangs des Prozesses
        \item Erstellung eines Happy Path Top-Level Modells
        \item Erweiterung um Ausnahmesituationen
        \item Ausführung durch Unterprozesses
        \item optionalen Ergänzung von Nachrichtenflüssen
    \end{enumerate}
    \cite[vgl.][S. 63ff]{stiehl_prozessgesteuerte_2013}
    
    Anschließend werden die Detailinformationen zusammengetragen. Beispielsweise könnten diese Auskunft darüber geben, welchen Beitrag ein Schritt für den Gesamtprozess leistet, welche Daten er wie nutzt, ob er häufiger ausgeführt wird, ob es Ausnahmen gibt. \cite[vgl.][S. 66f]{stiehl_prozessgesteuerte_2013} 
    
    Zuletzt wird noch der Datenfluss beschrieben. Dabei kann es sich um prozessinterne Daten handeln, also Informationen, die zwischen den einzelnen Aufgaben innerhalb eines Prozesses relevant sind. Es kann sich aber auch um langlebigere Informationen handeln, diese sind dabei entsprechend zu kennzeichnen und werden auch nach dem Prozess noch vorhanden sein. \citep[vgl.][S. 67]{stiehl_prozessgesteuerte_2013}
    
    \item Nun kommt es zum sogenannten ''Modeling beyond the happy path'' \citep{camunda_services_gmbh_modeling_2024}. In diesem Schritt werden die rein fachlichen Ausnahmesituationen genauer betrachtet und gegebenenfalls ergänzt, ob Wiederholungen durchgeführt werden sollen oder sogar ein kompletter Abbruch notwendig ist. \citep[vgl.][S. 67]{stiehl_prozessgesteuerte_2013}
    
    \item Hier sollen zunächst die Geschäftsobjekte, die für jeden Prozessschritt notwendig sind, betrachtet und daraus Relationen gebildet werden. Anschließend wird daraus ein Datenmodell erstellt. \citep[vgl.][S. 69f]{stiehl_prozessgesteuerte_2013}
    
    \item An die Bedürfnisse der Nutzer angepasste Benutzeroberflächen werden entwickelt. Ziel dabei ist es, den Nutzer bestmöglich in seiner Rolle im Prozess zu unterstützen. \citep[vgl.][S. 70f]{stiehl_prozessgesteuerte_2013}
    
    \item Zuletzt werden dann die fachlichen Services definiert. Dabei sind ausschließlich Schnittstellen aus Sicht der prozessgesteuerten Anwendung zu definieren. Ebenfalls kann man hier einen Servicevertrag definieren, der als Zwischenebene zwischen fachlicher Ebene und technischer Ebene dient. \citep[vgl.][S. 72f]{stiehl_prozessgesteuerte_2013}
\end{enumerate}

\clearpage
\subsection{Technologien einer Prozess Engine}
\subsubsection{Grundlagen von BPMN 2.0}
Die für den \ac{PDA} notwendigen Geschäftsprozesse, die auch im vorigen Kapitel schon kurz als fachliche Prozesse angeschnitten wurden, sind eine Folge aus koordinierten Aktivitäten. Diese Geschäftsprozesse benötigen Zeit, verbrauchen Ressourcen und haben unter anderem einen definierten Start und ein Ende \citep[vgl.][S. 1]{gopfert_geschaftsprozessmodellierung_2013}. 

Um diese Prozesse einheitlich modellieren zu können, wie in \fullref{enu:item:spezifikation_von_prozessgesteuerten_anwendungen:prozessmodellierung} beschrieben, wurde \ac{BPMN} 2.0 Standard definiert. Dieser wurde 2011 von \acl{OMG} verabschiedet \citep[vgl.][S. 8]{freund_praxishandbuch_2017}. Im Jahr 2013 wurde \ac{BPMN} 2.0 auch von der \acl{ISO} als Standard veröffentlicht \citep[vgl.][]{iso_isoiec_2013}.

Um ein weiteres Verständnis dieser Bachelorarbeit zu gewährleisten, wird hier ein kurzer Überblick über \ac{BPMN} 2.0 gegeben. Hier wird kein Anspruch auf Vollständigkeit erhoben, da dies den Umfang dieser Bachelorarbeit übersteigen würde. Für detailliertere Informationen zum \ac{BPMN} Standard werden die Bücher \citep{gopfert_geschaftsprozessmodellierung_2013}, \citep{bruce_bpmn_2012} oder \citep{freund_praxishandbuch_2017} empfohlen.

Ein Vorteil bei der Modellierung von Geschäftsprozessen mit \ac{BPMN} ist es, dass man als Werkzeug nicht nur eine rein visuelle Notation an die Hand bekommt, sondern auch die Möglichkeit, ein formales Metamodell der Prozesse zu beschreiben, das auch noch formale Syntax und Symbolsemantik vorgibt. \citep[vgl.][S. 8]{freund_praxishandbuch_2017}. \\
Das Datenformat, das dafür im \ac{BPMN} 2.0-Standard für die Beschreibung der Modelle spezifiziert wurde, ist \ac{XML} \citep[vgl.][]{object_management_group_about_2010}.

\ac{BPMN} bietet viele Freiheiten, und das einzige, das von der \ac{BPMN}-Spezifikation verlangt wird, ist die Vollständigkeit der Diagramme. Daher ist es wichtig, gewisse Qualitätsstandards zu definieren, welche auch für die nachfolgenden Modelle gelten werden. \citep[vgl.][S. 5]{bruce_bpmn_2012}

\begin{itemize}
    \item \textbf{Fehlerfreiheit}; Regeln der \ac{BPMN} Spezifikation werden befolgt.
    \item \textbf{Klarheit}: Diagramm ist für sich selbst eindeutig Verständlich. \label{enu:item:qualitatsstandards:klarheit}
    \item \textbf{Vollständigkeit}: Vollständiger Aktivitätsfluss und Zusammenspiel mit externen Entitäten gegeben.
    \item \textbf{Konsistenz}: Modellierungen unterschiedlicher Menschen unter gleichen Anforderungen führen zum einem sehr ähnlichen Diagramm.
\end{itemize}
\citep[vgl.][S. 5]{bruce_bpmn_2012}

\paragraphandnewline{Relevante \ac{BPMN} Symbole}

\abbildung{0.85\textwidth}{img/proc;Beispielprozess.png}{fig:tasks}{Beispielprozess}

Um nachfolgende \ac{BPMN}-Modellierungen einfacher nachvollziehen zu können und den Einstieg und den Zusammenhang zwischen den nachfolgenden Symbolen zu vereinfachen, ist hier ein beispielhaftes \ac{BPMN} Modell dargestellt. Die hier gezeigten Symbole sind dabei nur ein kleines Subset der tatsächlich verfügbaren Symbole und sollen eine mögliche Anordnung zeigen. 

Nachfolgend werden alle vorkommenden \ac{BPMN}-Symbole aufgelistet. Orange gefärbte sind solche, welche von der ausgewählten Process Engine ausgeführt werden können. Alle in schwarz sind allerdings irrelevant, weil diese entsprechend nicht unterstützt werden. Mehr zur Prozess Engine Auswahl in \fullref{sec:process_engine_auswahl}. Ausführlicher werden nicht alle orangen Symbole erklärt, sondern nur die, welche auch später verwendet werden.

Nicht explizit erklärt, aber auch überall verwendet wird der verbindende Weg,  dieser wird ab jetzt Sequenzfluss genannt. Ein Sequenzfluss beschreibt dabei die Logik, in welcher Reihenfolge der Prozess umgesetzt wird. \citep[vgl.][S. 13]{bruce_englisch_2011} 

\abbildung{0.3\textwidth}{img/spec:pool.png}{fig:pool}{Teilnehmer Pools}{\citep[][]{camunda_services_gmbh_bpmn_2024}}
Das dargestellte Bild zeigt einen Pool. ''Pools'' gibt es dabei in zwei Geschmacksrichtungen, einmal als  White-Box-Pools und als Black-Box-Pools. Ein White-Box-Pool ist dabei ein Pool, in dessen Lanes ein Geschäftsprozess modelliert ist. Dabei werden die im Pool vorhandenen Lanes mit den Namen beschriftet. Auf den Lanes wird beschriftet, welche Rolle für die Abarbeitung der Aktivitäten in diesem Bereich zuständig ist. Sollten die Lanes eines Pools allerdings leer sein, beziehungsweise nicht vorhanden, spricht man von einem Black-Box-Pool. Das bedeutet im Wesentlichen, dass nicht bekannt ist, was dort passiert. \citep[vgl.][S. 55]{bruce_bpmn_2012}

\abbildung{0.8\textwidth}{img/spec:events.png}{fig:events}{BPMN Ereignisse}{\citep[][]{camunda_services_gmbh_bpmn_2024}}

In dieser Auflistung sind Symbole vom Typ Multiple und Parallel Multiple nicht vorhanden. Grund dafür ist, dass diese von der ausgewählten Prozess Engine Camunda, die später im Kapitel \fullref{sec:process_engine_auswahl} näher ausgeführt wird, nicht unterstützt werden.

Nach Silver ist ein \ac{BPMN} Event die Beschreibung dafür, wie ein Prozess auf ein Signal oder einen Hinweis reagiert. Auch wird durch ein Event beschrieben, wie der Prozess Signale oder Hinweise ausgibt, nachdem etwas passiert ist. \citep[vgl.][S. 103]{bruce_bpmn_2012}

Events, welche in einem Prozess das Ausgeben von Signalen oder Hinweisen beschreiben, sind alle, welche in der Abbildung unter ''Start'' beziehungsweise unter ''Intermediate''-''Throw'' und ''End'' gelistet sind. Die restlichen ''Intermediate'' Events beschreiben, wie der Prozess auf das Empfangen von Signalen oder Hinweisen reagieren soll.

Unter Start, Normal und None ist in der Abbildung das normale Startereignis zu finden. Das startet einen Prozess und gibt den Auslöser beziehungsweise den Grund an, warum der Prozess eintritt \citep[vgl.][S. 49]{bruce_bpmn_2012}.

Der Gegensatz zu Starteereignissen stehen die End-Ereignisse. Die mit dem dicken Rand gekennzeichneten Symbole sind essenziell, um festzulegen, wann ein Prozess zu Ende geht. Das kann über verschiedene Arten passieren. Ein Prozess kann erfolgreich beendet werden oder auch mit einem Fehler. Das erlaubt es dann den darauf folgenden Prozessen, darauf zu reagieren, da diese auf die Endereignisse reagieren können. \citep[vgl.][S. 55f]{bruce_englisch_2011}

Ein weiteres Ereignis ist das intermediate Escalationevent, auf Deutsch unterbrechendes Eskalationsevent. Damit würde signalisiert werden, dass im Prozess eine Ausnahmesituation eintritt. Verwendet wird dieses Event in dieser Arbeit in seiner ''start event subprocess escalation'', ''intermediate boundary escalation'' und ''end escalation'' Variante. Die ''start event subprocess escalation'' wird dabei verwendet, um eine zuvor geworfene Eskalation zu behandeln. Der Prozessschritt, an dem eine ''intermediate boundary escalation'' angeheftet ist, kann abgebrochen werden, solange er aktiv ist. Im Falle eines Abbruchs durch eine Eskalation wird der Sequenzfluss an der Position des Eskalationsevents fortgesetzt, statt dem ursprünglichen Sequenzfluss der Aktivität herauszufolgen. Zuletzt kommt noch die ''end escalation'', diese funktioniert wie ein normales End-Ereigniss. Hier wird der Sequenzfluss beendet und die Eskalation wird an den ummantelnden Prozess weitergegeben. \citep[vgl.][S. 107, 111f]{bruce_englisch_2011}

Auch Nachrichtenereignisse wie ''message start event subprocess'' und ''message intermediate catch'' oder ''message intermediate boundary'' werden verwendet. Diese erlauben es dem Prozess, der diese verwendet, auf Nachrichten von außerhalb zu reagieren. Wie bei Eskalationsereignissen, wenn angeheftet an eine aktive Aktivität, wird die Aktivität beim Eintreffen einer Nachricht sofort abgebrochen und der Prozess folgt dem Sequenzfluss, der am Message Ereignis festgelegt wurde. Die anderen funktionieren von der Idee her genauso wie bei der Eskalationsvariante, nur dass das Auslösen durch eine Nachricht erfolgt und weniger einen Ausnahmefall impliziert. \citep[vgl.][S. 99f, 102]{bruce_englisch_2011}

Das Endereignis für Error verhält sich genauso wie das Eskalationsereignis, allerdings ist nur die Bedeutung dahinter anders. Hier liegt der Fokus mehr darauf, dass es einen technischen Fehler gibt \citep[vgl.][S. 104ff]{bruce_englisch_2011}

Die Timer Events, vor allem die ''timer intermediate boundary non-interrupt'' und ''timer intermediate boundary'' sowie ''timer intermediate catch'' Events, sind die letzten relevanten Events, welche in den späteren Prozessen verwendet werden. Diese funktionieren wie die anderen ''intermediate'' Events, nur mit dem Unterschied, dass diese durch einen Timer ausgelöst werden statt durch zum Beispiel eine Nachricht oder Eskalation. Auch neu ist hier das zum ersten Mal relevant gewordene ''timer intermediate boundary non-interrupt'' Event. Wenn dieses gestartet wird, wird die aktive Aktivität weiter ausgeführt, aber gleichzeitig wird auch noch ein zweiter Sequenzfluss beschritten und parallel zum Ursprungspfad ausgeführt. \citep[vgl.][S. 94]{bruce_englisch_2011}

\abbildung{0.45\textwidth}{img/spec:data_artefacts.png}{fig:data_artefacts}{Data Artefacts}{\citep[][]{camunda_services_gmbh_bpmn_2024}}
''Data Artefacts'' sind Datenspeicher und stellen Informationseinheiten dar. Diese können entweder in einem externen System hinterlegt sein oder auch innerhalb eines Prozesses können die Daten verwaltet werden. Verbunden werden diese durch einen Datenfluss, der einfach nur widerspiegelt, wer von was liest, beziehungsweise schreibt. Allerdings ist keines der Symbole von der Prozess-Engine funktional unterstützt, wie ebenfalls im \fullref{sec:process_engine_auswahl} ausgeführt. Dennoch werden diese gegebenenfalls zu Dokumentationszwecken vereinzelt vorhanden sein. \citep[vgl.][S. 59]{bruce_bpmn_2012}

%* Sequenzfluss ✅
%* Externer Blackpool ✅
%* Startereignis ✅
%* Endereignis ✅
% startendes Eskalationsevent ✅
% unterbrechendes Eskalationsstartereignis ✅
% werfendes Eskalationsendereignis ✅
%* startendes Empfangsevent event-subprozess ✅
%* unterbrechendes angeheftetes Nachrichtenevent ✅ 
%* unterbrechendes Nachrichtenevent ✅
% nicht unterbrechendes Timer-Event ✅
% unterbrechendes angeheftetes Timerevent ✅
%* werfendes beendendes Error-Event ✅
% Datenobjekt ✅
% Datenfluss ✅

% eventbasiertes Gateway
%* aufteilendes Gateway
%* zusammenführendes Gateway
%* paralleles Gateway

%* manual task
%* text-annotation
%* Call Process
%* Service Task
%* Human Task
%* Eventsubprozesse
%* Sende Aktivität

\abbildung{0.45\textwidth}{img/spec:gateways.png}{fig:gateways}{Gateways}{\citep[][]{camunda_services_gmbh_bpmn_2024}}
''Gateways'' steuern den Prozessfluss und entscheiden dabei, welche Pfade beschritten werden oder wo diese zusammengeführt werden.

Ein Event Gateway kann dabei nur in Kombination mit Events genutzt werden. Dieses Gateway würde zum Beispiel bei zwei nachfolgenden Nachrichten Events, zuerst den Weg, auch Sequenzfluss genannt, einschlagen, bei dem die Nachricht zuerst zutrifft. \citep[vgl.][S. 46]{bruce_bpmn_2012}

Ein exklusives datenbasiertes Gateway, oder alternativ kürzer XOR-Gateway, kann vereinend als auch teilend sein und dafür zuständig, bereits getroffene Entscheidungen auszuwerten. \citep[vgl.][S. 125f]{bruce_englisch_2011}. 

\clearpage
\abbildung{0.9\textwidth}{img/spec:subprocesses.png}{fig:subprocesses}{Unterprozesse}{\citep[][]{camunda_services_gmbh_bpmn_2024}}
Wenn ein Prozess sich in mehrere Teilschritte aufteilen lässt, kann man die Aktivitäten dieser einzelnen Teilschritte in ''Unterprozesse'' darstellen. In BPMN wird dabei in verschiedene Arten unterschieden. \citep[vgl.][S. 41]{bruce_bpmn_2012}

Beim eingebetteten Subprozess, welcher der Subprozess links mit dem dünnen Rand auf dem Bild ist, wird der Prozess in derselben Datei modelliert wie der Top-Level-Prozess selbst und dient vor allem dazu, eine bessere Top-down-Ansicht zu schaffen, indem gewisse logisch zusammenhängende Prozessschritte zusammengekapselt werden. Ein Subprozess ist aufgrund der Eigenschaft, innerhalb eines anderen Prozesses modelliert zu sein, ein Prozessschritt, der nicht wiederverwendbar in mehreren Prozessen verwendet werden kann. \citep[vgl.][S. 35, 37f]{bruce_englisch_2011}

Eine andere Variante, Unterprozesse zu nutzen, ist eine Call Activity. Diese ist in der Regel dafür zuständig, einen wiederverwendbaren Unterprozess zu starten. Anzumerken ist dabei, dass der aufgerufene Unterprozess, anders als bei einem eingebetteten Unterprozess, in einer separaten Datei modelliert ist und eher semantisch impliziert, dass der Prozess auch an anderen Stellen, in anderen Prozessen verwendet wird. \citep[vgl.][S. 38f]{bruce_englisch_2011}

\abbildung{0.9\textwidth}{img/spec:tasks.png}{fig:tasks}{Aufgaben, Aktivitäten}{\citep[][]{camunda_services_gmbh_bpmn_2024}}
Eine Aufgabe, Task oder auch Aktivität ist eine im Prozess geleistete Arbeitseinheit. Eine Aufgabe kann nicht mehr in weitere Elemente unterteilt werden. Der semantische Unterschied zwischen den Aufgaben wird durch das Icon, das die Bezeichnung des Tasktyps anzeigt, dargestellt und zeigt so, welche Bedeutung der Task zukommt. Im Falle einer User Task, auch Benutzer-Task, heißt dies, dass die Aufgabe nur mit Beteiligung oder ganz durch einen Menschen ausgeführt werden muss \citep[vgl.][S. 39ff]{bruce_bpmn_2012}.

\subsubsection{\acl{CMMN}}

Vollständigkeitshalber, um alle Prozessstandards der \ac{OMG} abzubilden, werden nun noch \ac{CMMN} und nachfolgend \acs{DMN} beleuchtet. Aufgrund des Fokus dieser Bachelorarbeit auf die strukturierten Prozesse wird \ac{CMMN} wenn dann nur eine untergeordnete Rolle einnehmen. Entsprechend eine kurze nachfolgende Erklärung. Für detailliertere Informationen zu \ac{CMMN} ist ebenfalls wie auch schon für \ac{BPMN} \cite{freund_praxishandbuch_2017} oder \cite{bruce_cmmn_2020} zu empfehlen.

\label{par:dreiklang_prozessverbesserungsstandards}
Mit \ac{BPMN} 2.0 wird eigentlich alles angeboten, was für einen Umgang mit Geschäftsprozessen notwendig ist. Trotzdem wurde neben \ac{BPMN} später von der \ac{OMG} auch der \ac{CMMN} Standard veröffentlicht. Laut der \ac{OMG} ist dieser mit dem später veröffentlichten \ac{DMN} Standard Teil des Dreiklangs der Prozessverbesserungsstandards. Die Idee dabei ist, dass \ac{BPMN}, \ac{CMMN} und \ac{DMN} in Kombination verwendet werden können. \citep[vgl.][]{object_management_group_case_2016}

\ac{CMMN} soll dabei bei der unstrukturierten Prozessmodellierung verwendet werden. Diese können natürlich auch mit \ac{BPMN} modelliert werden, das kann aber zu mehreren Problemen führen. Einerseits läuft man in die Gefahr, das Ziel der Klarheit, wie definiert in \fullref{enu:item:qualitatsstandards:klarheit}, zu verletzen. Gerade wenn es fachlich notwendig ist, aus einem Gateway 4, 5 ausgehende Wege zu modellieren, und es zusätzlich dann noch notwendig ist, mehrfach zu diesem Gateway zurückzuspringen, kann das Modell schnell unübersichtlich werden \citep[vgl.][S. 9]{freund_praxishandbuch_2017}. \ac{BPMN} bietet dafür zwar ein Ad-Hoc-Symbol an, dieses kann aber auch schnell unübersichtlich werden, sobald beispielsweise für die Wege verschiedenste Regeln notwendig sind. 

\subsubsection{\acl{DMN}}

Wie in \fullref{par:dreiklang_prozessverbesserungsstandards} angesprochen wurde, ist auch \acl{DMN} von der \ac{OMG} veröffentlicht worden. Es ist der jüngste der drei Prozess-Standards und damit der dritte im Bunde. Hierbei handelt es sich um einen Standard, der wie \ac{CMMN} und \ac{BPMN} ebenfalls ein in XML beschriebenes formales Metamodell besitzt. Im Gegensatz zu \ac{BPMN} und \ac{CMMN} ist es dabei nicht der Anspruch dieses Standards, Prozesse modellieren zu können. \citep[vgl.][S. 10f]{freund_praxishandbuch_2017} 

Hauptzweck von \ac{DMN} ist die Unterstützung bei der Modellierung von Entscheidungslogik innerhalb von Geschäftsprozessen. Durch die Nutzung von Entscheidungstabellen können komplexe Entscheidungen, die beispielsweise von spezifischen Bedingungen oder Regeln abhängig sind, einfach visualisiert und standardisiert werden. \citep[vgl.][]{object_management_group_dmn_2025}

\clearpage
\subsection{Die Prozess Engine in einer prozessgesteuerten Anwendung}
\subsubsection{Funktionen einer Prozess Engine}
Um zu dem Ziel dieser Arbeit zu kommen, eine \acl{PA} und die damit verbundenen \ac{BPMN}-Modelle zum Ausführen zu bringen, benötigt man zwangsläufig eine Prozess Engine. Damit steht diese als Infrastrukturkomponente verwendete Technologie im Herzen einer \acl{PA}. Da diese so von zentraler Bedeutung ist, ist es wichtig, die Aufgaben neben der Ausführung der Geschäftsprozesse auch kurz abzureißen. \citep[vgl.][]{stiehl_prozessgesteuerte_2024}

Eine Prozess Engine ist eine Softwarekomponente, die zur Automatisierung von Geschäftsprozessen dient. Zur Ausführung müssen Prozessmodelle definiert werden, wie nachfolgend bei \fullref{sec:modellierung} zu sehen ist. \citep[vgl.][]{leymann_definition_2024}

Wie vorher beschrieben, werden \ac{BPMN} Prozesse in \ac{XML} definiert. Diese Modelle können von einer Prozess Engine ausgelesen, interpretiert und zur Ausführung gebracht werden. Damit dies funktionieren kann, müssen diese natürlich alle technischen Details beinhalten, die zur Ausführung notwendig sind. \citep[vgl.][S. 226]{freund_praxishandbuch_2017}

Geschäftsprozesse können teilweise bis zu mehrere Monate oder sogar noch länger laufen. In diesen Zeiträumen kann es durchaus passieren, dass das bestehende Prozessmodell angepasst wird. Dadurch ergibt sich die Anforderung, dass eine Prozess Engine mit mehreren Modellversionen parallel arbeiten kann oder gegebenenfalls die Modelle auch auf ihre neue Version migrieren kann. Das hilft auch dabei, dass jegliche Änderungen in einem \ac{BPMN}-Diagramm und im Lebenszyklus einer Prozess-Instanz nachvollzogen werden können. \citep[vgl.][S. 226]{freund_praxishandbuch_2017}.

Eine weitere Funktion von einer Prozess Engine ist es, vollautomatisch die Metadaten oder auch die konkreten Zustandsdaten, die der Prozess hatte, während der Steuerung von Prozessinstanzen zu sammeln, um Einblicke in die Prozesseffizienz und potenzielle Engpässe zu bieten und eine Nachvollziehbarkeit von einzelnen Prozessen möglich zu machen. Daten, die dabei gesammelt werden, sind z.B. wann eine Aktivität gestartet wurde, wie lange diese gedauert hat, welche Daten als Inputparameter und Outputparameter hinein- bzw. herausgekommen sind. \citep[vgl.][S. 7, 226]{freund_praxishandbuch_2017} \citep[vgl.][]{stiehl_prozessgesteuerte_2024} 

Damit verbunden ist auch die Funktionalität, den aktuellen Status von Prozessinstanzen einzusehen und in das Verhalten einzugreifen, wie zum Beispiel durch das Abbrechen oder Neustarten einer fehlerhaften Instanz \citep[vgl.][S.226]{freund_praxishandbuch_2017}.

Eine Prozess Engine entscheidet darüber, welche Aufgaben und Serviceaufrufe unter welchen Bedingungen stattfinden. Ist also für die Orchestrierung der Services zuständig, indem sie interne oder externe IT-Systeme über Schnittstellen aufruft. \citep[vgl.][S. 6]{freund_praxishandbuch_2017}

\subsubsection{Prozess Engine Auswahl}
\label{sec:process_engine_auswahl}

Aufgrund der Relevanz der Prozess Engine und des Angebots, das herrscht, muss eine gewisse Auswahl getroffen werden. Nach tieferer Recherche wurden mehrere Prozess Engines, die aktuell auf dem Markt sind, gefunden. Eine Liste dieser ist weiter unten unter \fullref{tab:process_engine_list} zu finden. 

\paragraphandnewline{Kriterien}
Um die optimale Prozess Engine auszuwählen, wurde aus den gefundenen auf gewisse Kriterien geachtet. 
\begin{enumerate}
    \item Kostenlos
    \item Technisch robust
    \item Maintenance in der Zukunft
    \item Dokumentation
    \item \acs{BPMN}, \acs{CMMN}, \acs{DMN} Unterstützung
\end{enumerate}

\label{par:kostenlose_process_engines_auswahl}
Aufgrund unseres Einsatzzwecks in der Gastronomie und des geringen Budgets sollen mögliche Kosten für die Zukunft gering gehalten werden. Auch soll ein möglicher zukünftiger kommerzieller Einsatz nicht durch unerwartete Extrakosten für Lizenzen verbunden sein. Daher ist es ein wichtiges Kriterium, dass es kostenlos ist.

Technisch robust bezieht sich dabei auf die Implementierung auf technischer Ebene. Es ist wichtig, dass die Engine wenig Bugs hat und eine zufriedene Nutzerbasis damit auch bei der späteren Implementierung und Ausführung der Prozesse wenig Workarounds oder Ähnliches gefunden werden müssen. Hier ist es auch relevant, auf welchem technischen Stand an sich die Engine ist. Zum Beispiel ob, wenn diese auf Java basiert, sie eine neue Version oder eine alte verwendet. 

Auch dieser Punkt bezieht sich auf die technische Sicht. Maintenance in der Zukunft bezieht sich dabei auf den Zeitraum, in dem die Engine noch Updates bekommt. Das ist insofern relevant, um vor zukünftig auftretenden \acs{CVE} geschützt zu sein  \citep{mitre_cve_2024}.

Um die Engine überhaupt benutzen zu können, ist es unerlässlich, dass eine ausreichende Dokumentation vorhanden ist und es eine gesunde Community gibt.

Da es Prozess Engines gibt, die unter anderem aufgrund der Existenz von \ac{CMMN} nicht den gesamten \ac{BPMN} Standard unterstützen, ist es bei der Auswahl unerlässlich, dass entweder beide Standards oder der \ac{BPMN} Standard vollständig von der ausgewählten Engine ausgeführt werden kann. \ac{DMN} wird voraussichtlich keine relevante Rolle spielen, daher ist der Support eher als optionaler Pluspunkt zu bewerten.

\clearpage
\begin{center}   
\begin{table}[]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \thead{Prozess Engine} & \thead{Webseite} \\
        \hline

        \href{https://github.com/Activiti/Activiti}{Activity} & 
        \href{https://github.com/Activiti/Activiti}{https://github.com/Activiti/Activiti} \\
        \hline

        \href{https://www.processcube.io/}{Process Cube} & 
        \href{https://www.processcube.io/}{https://www.processcube.io/} \\
        \hline
        
        \href{https://www.spiffworkflow.org/}{Spiffworkflow} & 
        \href{https://www.spiffworkflow.org/}{https://www.spiffworkflow.org/} \\
        \hline

        \href{https://github.com/camunda/camunda-bpm-platform}{Camunda 7} & 
        \href{https://github.com/camunda/camunda-bpm-platform}{https://github.com/camunda/camunda-bpm-platform} \\
        \hline

        \href{https://camunda.com/}{Camunda 8} & 
        \href{https://camunda.com/}{https://camunda.com/} \\
        \hline
        
        \href{https://github.com/cibseven/cibseven}{CIB Seven} & 
        \href{https://github.com/cibseven/cibseven}{https://github.com/cibseven/cibseven} \\
        \hline
        
        \href{https://operaton.org/}{Operaton} & 
        \href{https://operaton.org/}{https://operaton.org/} \\
        \hline

        \href{https://www.flowable.com/open-source}{Flowable Opensource} & 
        \href{https://www.flowable.com/open-source}{https://www.flowable.com/open-source} \\
        \hline

        \href{https://www.flowable.com/}{Flowable Enterprise} &
        \href{https://www.flowable.com/}{https://www.flowable.com/} \\
        \hline

        \href{https://kogito.kie.org/}{Kogito} &
        \href{https://kogito.kie.org/}{https://kogito.kie.org/} \\
        \hline
    \end{tabular}
    \caption{Existierende BPMN/CMMN Prozess Engines}
    \label{tab:process_engine_list}
\end{table}
\end{center}
\paragraphandnewline{Bewertung Prozess Engines}
Es gibt durchaus auch andere Prozess Engines, wie JPMN \citep{apache_software_foundation_jbpm_2024}. Diese Liste legt aber keinen Wert auf Vollständigkeit, sondern soll nur dabei helfen, einen Überblick zu gewinnen. Zudem soll der Fokus dieser Bachelorarbeit auf der Konzeption und Implementierung liegen, nicht auf einer allumfassenden Auswahl und Vergleich verschiedener Prozess Engines.

Wie hier in dem Blog von Flowable, siehe \cite{holmes-higgin_digital_2019}, zur Entwicklung von Prozess Engines zu lesen ist, sind die meisten Prozess Engines auf Basis von JPMN und später Activity 5 entstanden. Beispiele hierfür sind z.B. Flowable, Activity, Camunda und wiederum dessen Folks Operaton und CIB Seven. Daher ist davon auszugehen, dass deren technische Robustheit und Support von \ac{BPMN} nicht gravierend unterscheidet.

In den nachfolgenden Ausführungen sind bei den betrachteten Prozess Engines alle kostenpflichtigen Varianten aufgrund der Ausführungen in \fullref{par:kostenlose_process_engines_auswahl} bereits aussortiert. 

Die kostenpflichtigen Prozess Engines sind dabei der Process Cube, Camunda 8 und Flowable Enterprise.

\begin{itemize}
    \item \textbf{Spiffworkflow} bietet einen noch nicht ganz ausreichenden BPMN Standards. So sind 50 von 69 noch nicht unterstützt \citep[vgl.][]{funk_creating_2023}. Zudem ist das Community Ecosystem merkbar klein und technisch noch nicht ganz ausgereift \citep[vgl.][]{spiffworkflow_overview_2024}.

    \item \textbf{Camunda 7} steht vor mehreren Problemen, einerseits fällt der offizielle Support der Prozess Engine für die letzte Version im Jahr 2027 weg \citep[vgl.][]{camunda_services_gmbh_support_2024}. Andererseits ist die Engine auch nicht mehr auf dem neuersten technischen Stand, gerade in Performance Hinsicht \citep[vgl.][]{johnson_why_2023}. Auch kleinere technische Einschränkungen wie kein echtes paralleles Bearbeiten von Tasks sind Malusse von Camunda 7 \citep[vgl.][]{camunda_services_gmbh_camunda_2023}. Bei Camunda 7 gibt es zudem einige nicht unterstützte \ac{BPMN} 2.0 Symbole \citep[vgl.][]{camunda_services_gmbh_bpmn_2024}. 
    
    Davon abgesehen hat Camunda 7 eine relativ große Community und bietet Support für \ac{CMMN} an \citep[vgl.][]{camunda_services_gmbh_cmmn_2024}. Auch \ac{DMN} wird supportet und zudem bietet Camunda 7 einen eigenen Modeller sowie ein eigenes Control Dashboard für aktuelle Prozesse \citep[vgl.][]{camunda_services_gmbh_dmn_2024}. In Bezug auf den wegfallenden Maintainance gibt es Community Anstrengungen wie CIB Seven und Operaton. Diese fokusieren sich jeweils darauf, das weiterhin Support geliefert wird \citep[vgl.][]{cib_open_2024}. Oder das Camunda 7 sogar technisch überholt und neugeschrieben wird \citep[vgl.][]{zoller_operaton_2024}.
    
    \item \textbf{Activity} ist eine neugeschriebene Prozess Engine welche sich auf eine Microservice Architektur fokusiert \citep[vgl.][]{activity_open_2024}. Die Community um Activity ist ebenfalls nicht sonderlich groß und aber es werden eigene Modellierungstools und Überwachungstools angeboten \citep[vgl.][]{activity_activiti_2024}. Von Activity wird zwar \ac{CMMN} nicht unterstützt, die Ad-Hoc Funktionalität ist aber implementiert und kann daher ersetzten verwendet werden \citep[vgl.][]{hyland_activiti_2017}. 

    \item \textbf{Flowable Opensource} ist mit seiner neuen Version 7 auf einem neuen technischen Stand. Außerdem wird der vollständige \ac{BPMN} Standard unterstützt. Auch die Dokumentation ist für die Zwecke dieser Bachelorarbeit ausreichend. Für die Modellierung bietet Flowable zwar \ac{BPMN}, \ac{DMN} und \ac{CMMN} Modellierung über sein Opensource Repository an, allerdings nur bis zur Version 6.8.2. Seit der Version 7 wird Modellierung nur noch über den Online Service von Flowable angeboten. \citep[vgl.][]{flowable_flowable_2024} 
    
    \item \textbf{Kogito} ist ebenfalls eine Opensource Prozess Engine, welche allerdings nicht alle \ac{BPMN} Komponenten unterstützt \citep[vgl.][5.2.2]{kogito_kogito_2024-1}. Auch ist anzumerken, dass aktiv an Kogito weiterentwickelt wird und der \ac{BPMN} Support ausgebaut \citep[vgl.][]{redhat_release_2024}. 
\end{itemize}

\paragraphandnewline{Ergebnis}
Aufgrund der obigen Betrachtung wurde sich für folgendes Modell entschieden. Zur Ausführung und Überwachung der Prozesse wird Camunda 7 verwendet. Bei dem Problem, dass die Wartung wegfällt ab 2027, also dem Auslaufen der aktuellen Camunda 7 LTS Version, wird dies durch CIB Seven oder alternativ Operaton in Angriff genommen. Zur Modellierung wird der Camunda Modeler verwendet und sollte es notwendig sein \ac{CMMN} zu modellieren, wird dies im Flowable Modeler geschehen. 

Dieser Stack bietet den Vorteil, dass eine kostenlose Prozess Engine verwendet wird, welche fast alle notwendigen \ac{BPMN} Komponenten unterstützt und gleichzeitig eine Modellierungs-App und Admin-App, das Cockpit, mitliefert.

\section{Prozessgestaltung für die Gastronomie}
\label{sec:prozesse_gastronomie}
\subsection{Problemverständnisschärfung durch Kommunikation mit Gastronomen}
\label{sec:problemverstaendnis_gastronomie}
Bei Gesprächen mit Gastronomen in Ingolstadt, hervorzuheben sind dabei Bravo Pizza napoletana und District Five Coffee Roasters - Café.

Erstere sind Gastronomen, die beim Kunden ein Willkommensgefühl auslösen wollen, indem sie diese Kunden immer an der Kasse vor der Küche bestellen lassen. Ziel ist dabei, dass die Kunden den dortigen steinernen Pizzaofen sehen. Das mag erst einmal trivial wirken, aber es fügt dem Ambiente-Gefühl einiges hinzu, zu wissen, wo die Pizza hergestellt wurde.
Relevant für diese Art von Gastronomen ist daher, dass die Kunden dieses Ambiente beim Bestellen mitnehmen können, und lehnen daher eine Online-Bestellung oder auch gerade eine Tisch-Bestellung vom Außenbereich aus ideologischer Sicht ab.

Zweitere hingegen ist ein Café, das aktuell auch die Kunden bei der Kasse bestellen lässt. Das Ziel ist es hier allerdings, Arbeitszeit und -last zu sparen. Die Kunden suchen sich hier einen Tisch und gehen anschließend zum Bestellpunkt, bestellen dabei bei einem der Mitarbeiter. Dabei stehen diese, gerade bei Stoßzeiten, in einer längeren Schlange.

Auch werden bei Änderungen in der Speisekarte für alle Speisekarten die Änderungen auf den entsprechenden Blättern neu ausgedruckt. Was nicht unbedingt viel Flexibilität zeigt, die man auch brauchen kann, wenn an einem Abend gewisse Gerichte nicht mehr verfügbar sind.

Andererseits gibt es auch für den Kunden Verbesserungspotential. Gerade wenn man durch die Stadt geht und Hunger auf gewisse Gerichte hat, wäre es natürlich einfach für den Fußgänger, sich zu jedem Restaurant hinzugeben und sich zu überlegen, ob es die entsprechenden Gerichte gibt. Wenn nur wenige Restaurants in der Umgebung sind, ist das möglich, ebenfalls unter der Voraussetzung, dass diese ihre Speisekarte auch aushängen. Aber auch das kann bei mehreren Gastronomien schnell anstrengend werden.

Es gibt also in der Gastronomie mehrere verschiedene Probleme, bei denen angesetzt werden kann. Einerseits gibt es, wie beschrieben, die Probleme von langen Warteschlangen, hoher Arbeitslast, dem Aufwand bei Speisekartenänderungen und der fehlenden Markttransparenz auf Seiten der speisenden Kundschaft.

Lösungen hierfür wären, dass man alle Probleme hierfür zusammen betrachtet. Klar wäre es zielführend, auf dem Handy einfach kurz zentral auf einer App die umliegenden Speisekarten zu sehen und nach Gerichten zu filtern, welche dazu passen. An der Stelle bietet sich auch viel Potenzial, wie etwa durch eine KI-gestützte Suche und eine mögliche Integration eines One-Click-Buy-Konzeptes \citep[vgl.][]{amazon_oneclick_2025}. Eine ganzheitliche Betrachtung, bei der der Kunde von einer Übersicht über die aktuelle Auslastung und die voraussichtlichen Bedienungszeiträume profitiert, um die zu erwartende Wartezeit bis zur Abholung des Essens im Falle von Selbstbedienung besser einschätzen zu können, und gleichzeitig durch einen Buzzer oder eine Online-Benachrichtigung informiert wird, sobald das Essen fertig ist, würde sowohl den Kunden als auch der Gastronomie durch erhöhte Sichtbarkeit und Effizienz zugutekommen.

Um dies zu erreichen, müssten einheitliche digitalisierte Standardprozesse für die Gastronomie festgelegt werden, die am besten auch die oben genannten Probleme adressieren. Einerseits müsste man hier unterscheiden zwischen Restaurants, die alles mit Bedienungen regeln, und Selbstbedienungsrestaurants, die keine oder nur Bedienstete für eingeschränkte Aufgaben haben.

\subsection{Modellierung der Gastronomieprozesse nach dem \acl{PDA}}
\label{sec:modellierung}
Zu Beginn der Modellierung ist festzuhalten, dass es das Ziel dieser Arbeit ist, das Verwalten für den Gastronomen und den Arbeitsablauf der Köche und Bedienungen zu vereinfachen, sondern auch im weiteren Schritt für die Kunden.

Die folgenden Kern-Prozesse wurden ebenfalls unter anderem identifiziert. 

\begin{itemize}
    \item Verwaltungsprozess zum Bearbeiten der Speisekarten
    \item Top-Level-Prozess zum Zusammenfassen des Findens und der Bestellung 
    \item Selbstbedienungsrestaurantprozess
\end{itemize}

Auch andere Kern-Prozesse wurden identifiziert, allerdings sind diese nicht Teil dieser Bachelorarbeit, da diese in Kooperation entstanden sind. Die hier zusätzlich aufgelisteten Prozesse werden dabei in der Arbeit von \cite{ott_konzeption_2025} im Kapitel Prozessmodellierung behandelt und werden gegebenenfalls in den nachfolgenden Kapiteln referenziert. 

Umfassend werden also folgende Prozesse nicht in dieser Arbeit behandelt: 
\begin{itemize}
    \item Verwaltungsprozess zum Anlegen der Stamminformationen
    \item Verwaltungsprozess zum Onboarding von Restaurants
    \item Prozess zum Finden von Restaurants
    \item Bedienungsprozess für Bedienrestaurants
\end{itemize}

Ebenfalls wird dieser Stelle nochmal an \fullref{par:spezifikation_von_prozessgesteuerten_anwendungen} verwiesen, hier wurde das nachfolgende Vorgehen bereits grundlegend erklärt und wird nun für jeden der folgenden Prozesse angewendet.

% =================================
% = Main Process
% =================================
\subsubsection{Speisehauptprozess}
Damit die einzelnen Prozesse miteinander funktionieren, ist es notwendig, dass die Koordination zwischen den verschiedenen Kern-Prozessen hergestellt wird. Die Aufgabe dieses Top-Level-Prozesses ist es entsprechend, die verschiedenen Teilprozesse zu verheiraten. Die Verwaltungsprozesse werden dabei außen vor gelassen, weil diese einem anderen fachlichen Kontext dienen. 

\begin{itemize}
    \item \textbf{Prozess zum Finden von Restaurants}: Dieser Prozess umfasst das Auffinden von nahegelegenden Restaurants und deren Speisekarte. Ob diese bereits einen Account bei uns erstellt haben wird hier identifiziert sowie eine Auswahl des Endnutzers wird hier erwartet.
    
    \item \textbf{Selbstbedienungsrestaurantprozess}: Dieser Prozess umfasst Bestellung, Bezahlung, Kochvorgang und Abholung des Essens vom Kunden.
    
    \item \textbf{Bedienungsprozess für Bedienrestaurants}: Hier wird die Bestellung, Bezahlung, Kochvorgang, Tischverwaltung und Kochvorgang sowie Abholung des Essens geregelt. 
\end{itemize}

Die Randbedingungen um diesen Prozess sind relativ lose ohne Einschränkungen gestaltet. Gestartet werden kann dieser Prozess zu jedem beliebigen Zeitpunkt und auch sonst gibt es kaum Einschränkungen. Ziel ist es ja, dass dieser Prozess möglichst zugänglich ist.

\paragraphandnewline{Beteiligte Prozessrollen}
Ausgangsperson, welche diesen Prozess startet, ist der hungernde Kunde. Dieser sucht sich ein Restaurant, und hierbei kommen dann gegebenenfalls Köche, Küchengehilfen und gegebenenfalls Bedienungen ins Spiel. 

\paragraphandnewline{Visualisierung des Prozessflusses}
\abbildung{1\textwidth}{img/proc;SpeiseMain.png}{iref:SpeiseMain}{Top-Level-Prozess für die Restaurantbestellung}

In der Modellierung des Prozesses folgen wir zunächst dem Happy Path, dabei ist Folgendes beim Startereignis zu erkennen: in diesem Fall, dass ein hungriger Kunde vorhanden ist.

Der Sequenzfluss läuft daraufhin in ein zusammenführendes XOR-Gateway, welches bei der ausschließlichen Betrachtung des Happy Paths noch nicht relevant ist und daher fürs Erste ignoriert werden kann. Wie zu sehen ist, landet der Sequenzfluss nun in einer Call Activity. Diese Stelle im Prozess kennzeichnet somit den Start des Restaurantfindungsprozesses.
Die Gründe, warum hierbei auf eine Call Activity und nicht auf einen eingebetteten Subprozess zurückgegriffen wurde, sind dabei wie folgt. Anders als in einer Call Activity ist es in eingebetteten Subprozessen nicht möglich, einen Pool mit Lanes zu modellieren. Ein eingebetteter Subprozess ist nur ein ausführlicher Teilschritt, daher ist es auch nicht vorgesehen. Ein weiterer Vorteil ist, dass dabei eine parallele Entwicklung vereinfacht wird, da jeder an seinem Prozess feilen kann, ohne gegebenenfalls den Fortschritt des jeweils anderen zu beeinflussen. Um sicherzustellen, dass das Ganze funktioniert, werden bereits im Vorherein Schnittstellen zwischen den Prozessen definiert. Also, was der Unterprozess dem Top-Level-Prozess zurückgeben muss, beziehungsweise welche Eingangsparameter dieser benötigt. Was bei einem weiteren Blick auf das Prozessmodell ebenfalls auffällt, ist, dass gewisse Call Activities rot markiert sind. Die rote Markierung ist da, um hervorzuheben, dass diese Prozessschritte nicht Teil dieser Arbeit sind und daher nicht oder nur oberflächlich behandelt werden.

Nach Abschluss dieses Unterprozesses wird automatisch, programmatisch durch eine Service Task entschieden, ob das resultierende ausgewählte Restaurant ein Selbstbedienungsrestaurant ist oder ein Restaurant, welches Bedienungen beschäftigt. Der Selbstbedienungsrestaurant-Unterprozess wird aufgrund seiner Relevanz und Komplexität im nachfolgenden \fullref{sec:selbstbedienungsrestaurantunterprozess} behandelt.


Das darauf folgende XOR-Gateway teilt den Sequenzfluss abhängig vom Ergebnis der Service Task in Richtung des Selbstbedienungsrestaurant Prozess oder des Bedienungsrestaurant Prozess auf. Diese werden aus denselben Gründen wie beim vorigen Subprozess als Call Activity gestartet. Zum Schluss, nachdem der jeweilige Restaurant-Unterprozess abgeschlossen wurde, endet der Top-Level-Prozess dann mit einem nicht mehr hungrigen Kunden.

Nachdem der Beleuchtung des Happy Paths, kommt es nun zur Ausnahmebehandlung. Hierbei ist auf die beiden angehefteten Events, welche bei den Call Activities anhängen, zu verweisen. Beide sollen das Ausnahmeszenario, bei dem ein Nutzer sich doch noch für ein anderes Restaurant umentscheidet, nachspielen. Diese beiden angehefteten unterbrechenden Eskalationsevents führen entsprechend den Kunden wieder zurück bis vor den Restaurantfindungsprozess, weil dieser Prozess auch zur Aufgabe hat, dass der Kunde sein Restaurant auswählt.

Auf wie in \fullref{par:spezifikation_von_prozessgesteuerten_anwendungen} beschrieben, wird auf die optionale Ergänzung von Nachrichtenflüssen an dieser Stelle vorerst verzichtet, um die Komplexität des Prozesses zu reduzieren und weil es keine wirklichen Schnittstellen zu externen Systemen gibt.

\paragraphandnewline{Beschreibung des Datenflusses}
Entsprechend dem ARIS-Modell wurden die Organisationssicht, also wer was macht, die Funktionssicht, also was gemacht wird, und die Steuerungssicht, also der Ablauf, beantwortet. Jetzt fehlt nur noch die Datensicht, also womit was gemacht wird. \citep[vgl.][]{lackes_aris_2025}

Um zu dieser zu kommen, werden zunächst die Geschäftsobjekte betrachtet, die in diesem Prozess von Relevanz sind. Diese sind hier nur der Kunde und ein Restaurant.

Diese Geschäftsobjekte werden konkret, nachdem der Restaurantfindungsprozess durchgelaufen ist, herausgegeben. Hervorgehoben im Diagramm werden diese durch das Data Object Symbol. Einerseits soll das ausgewählte Restaurant und welcher Kunde für die Bestellung verantwortlich ist, dem Top-Level-Prozess zur Verfügung gestellt werden. Die Information darüber, wer dieser Kunde ist, ist optional, weil ein Kunde, der noch keinen Account hat, an dieser Stelle noch nicht blockiert werden soll. Wie der Datenfluss zeigt, werden diese beiden Geschäftsobjekte dann von den beiden Restaurantprozessen genutzt.

Um nicht jedes Mal Anpassungen im Laufe der nächsten Prozessbeschreibungen ein Datenmodell aufführen zu müssen, wird ein einheitliches Datenmodell mit der Aufschlüsselung der Geschäftsobjekte am Ende für alle Prozesse in \fullref{sec:datenmodell} zu finden sein.

% =================================
% = Selbstbedienungsrestaurantprozess
% =================================
\subsubsection{Bestellprozess für Selbstbedienungsrestaurants}
\label{sec:selbstbedienungsrestaurantunterprozess}
Um die in \fullref{sec:problemverstaendnis_gastronomie} beschriebenen Probleme von langen Warteschlangen und hoher Arbeitslast, welche unter anderem durch die Gebundenheit von Personal durch die Bestellungsaufnahme entstehen, zu reduzieren, wird dieser Prozess modelliert. Hierbei sind die einzelnen Teilschritte der Bestellung, Bezahlung, des Kochvorgangs und Abholung des Essens von besonderer Bedeutung, weil dies die primären Schritte sind, die den Prozess ausmachen.

Gerade bei der Bezahlung, beziehungsweise wann diese notwendig ist, soll viel Freiraum lassen, damit der Gastronom dies für sich passend gestalten kann.

Um den Prozess zu starten, ist es unbedingt notwendig, das Geschäftsobjekt über das Restaurant, welches im Zentrum hineingeben wird, anzugeben. Andernfalls soll der Prozess jederzeit startbar sein und hat daher keine weiteren Einschränkungen.

\paragraphandnewline{Beteiligte Prozessrollen}
Die relevanten Rollen hierbei sind der speisende Kunde und das Restaurant.
Während die meisten Aufgaben, gerade Bezahlung, Bestellung und die Abholung des Essens, fast ausschließlich, bis auf wenige Ausnahmen, vom Kunden zu erledigen sind, ist der Kochvorgang vollständig auf Seiten des Restaurants durchzuführen.

\clearpage
\paragraphandnewline{Visualisierung des Prozessflusses}
\abbildung{1\textwidth}{img/proc;Selbstbedienungsprozess.png}{iref:Selbestbedienungsprozess}{Toplevel-Prozess für das Selbstbedienungsrestaurant}

Auch hier wird zunächst wieder ausschließlich der Happy Path betrachtet. Direkt zu Beginn des Prozesses wird über eine Call Activity der ''Bestellprozess'' gestartet. In diesem wird vom Kunden verlangt, dass er eine Bestellung aufgibt. 

Im ''Zahlungsprozess'' wird zunächst geprüft, ob es vom Gastronom gewünscht ist, dass hier schon eine Zahlung durchgeführt werden soll. Falls ja, würde hier vom Kunden gezahlt werden, falls nein, würde erst zu einer späteren Stelle gezahlt werden. Anschließend wird die Bestellung an das Restaurant weitergeleitet.

Weiter gehend hat das Restaurant die Aufgabe, sich nun im ''Zubereitungsprozess'' um die Bestellung zu kümmern. Hier kommt der Rollenwechsel entsprechend zum Restaurant, wie man an der Line links erkennen kann. Sobald das Essen fertig ist, wird der Kunde benachrichtigt und der Sequenzfluss weiter in einen ''Zahlungsprozess''. 

Der zweite ''Zahlungsprozess'' ist dort, für den Fall, dass der Gastronom verlangt, dass vor der Abholung zu zahlen ist und nicht schon bei der Bestellung, das kann zum Beispiel notwendig sein, wenn ausschließlich Barzahlung erlaubt ist, aber online bestellt wurde. Der hier ausgeführte Unterprozess soll dabei exakt derselbe sein wie der am Anfang des Prozesses.

In dem darauf folgenden ''Abholungsprozess'' wird der Kunde erneut darüber benachrichtigt, dass er sein Essen jetzt zur Abholung bereitsteht. Nachdem der Kunde das Essen abgeholt hat, kann dieser, sofern er innerhalb des Restaurants isst und er noch nicht zahlen musste, nach dem Essen bezahlen. Das ist die letzte Möglichkeit, für den Gastronomen eine Zahlung zu verlangen.

Nun wird der Ausnahmepfad betrachtet, hier ist festzustellen, dass es 2 Eventsubprozesse gibt. In einem der beiden Eventsubprozesse kann durch ein unterbrechendes Eskalationsstartereignis, welches eine ''Stornierung'' ist, gestartet werden. Der Selbstbedienungsprozess ist abhängig davon, was das Restaurant vorgibt, zu jedem Zeitpunkt stornierbar. Sollte dabei der Kunde schon gezahlt haben, kann es daher notwendig sein, dass eine Zahlungsrückabwicklung stattfinden muss. 

In den ersten beiden Schritten soll der Prozess noch durch einen ''Restaurantwechsel'' abbrechbar sein. Die Abbruchfunktionalität wird über den anderen Eskalationssubprozess gehandhabt. Wenn das unterbrechende Eskalationsstartereignis durch einen ''Restaurantwechsel'' eintrifft, wird, wie im Top-Level-Prozess modelliert, der Kunde  direkt in die Liste der Restaurants zurückhüpfen.

\paragraphandnewline{Beschreibung des Datenflusses}
Die hier relevanten Geschäftsobjekte sind einerseits die Bestellung des Kunden und die Rechnung, die er davon bekommt. Andererseits die Restaurantinformationen selber, weil diese den Lauf des Prozesses beeinflussen. Die Bestellung entsteht dabei aus dem Bestellprozess und wird im Laufe des Prozesses, als Laufzeitinformation, in jeden weiteren Subprozess hineingereicht. Der Zahlungsprozess benötigt diese Informationen, um eine Rechnung zu erstellen, der Zubereitungsprozess, um zu wissen, was er zubereiten soll, und die Abholung, um zu wissen, wer was bestellt hat.

Die Restaurantinformationen werden dabei über den Top-Level-Prozess hineingegeben und an jeder Stelle verwendet, daher wird vorerst, um eine gewisse Übersichtlichkeit zu gewährleisten, darauf verzichtet, überall die Datenflüsse anzubringen.

\paragraphandnewline{Beteiligte Prozessrollen}
Die hier beteiligten Prozessrollen sind einerseits das Restaurant und der Kunde. Wie dem Pool und den Lanes zu entnehmen ist, sind alle Aufgaben, bis auf den Zubereitungsprozess, auf Seiten des Kunden. Der Abholungsprozess kann dabei auch Elemente des Restaurantprozesses beinhalten, aber dies lässt sich an dieser Stelle noch nicht festlegen; mehrheitlich wird dieser hier dem Kunden zugeordnet. 

\subsubsection{Bestellprozess}
\paragraphandnewline{Beteiligte Prozessrollen}
\paragraphandnewline{Visualisierung des Prozessflusses}
\abbildung{1\textwidth}{img/proc;Bestellprozess.png}{iref:Bestellprozess}{Bestellprozess}



\subsubsection{Zahlungsprozess}
Der nächste Prozess, der im Selbstbedienungsprozess gezeigt wird, ist der Zahlungsprozess. Der am meisten referenzierten Prozesse kommt diesem eine ganz besondere Bedeutung zu. Sollte hier im Nachhinein etwas geändert werden, kann es dazu führen, dass die anderen Prozesse gleich an mehreren Stellen auseinanderbrechen. Daher ist es ebenfalls wichtig, dass bei zukünftigen Änderungen dieser Prozesse auch alle anderen ausführlich getestet werden.

Im Zahlungsprozess soll durch eine Bestellung, beziehungsweise eine Liste aus zu zahlenden Objekten eine Rechnung erstellt werden. Dort kann z.B. auch Trinkgeld 

\paragraphandnewline{Beteiligte Prozessrollen}
\paragraphandnewline{Visualisierung des Prozessflusses}
\clearpage
\abbildung{1\textwidth}{img/proc;Zahlungsprozess.png}{iref:Zahlungsprozess}{Zahlungsprozess}

\abbildung{1\textwidth}{img/proc;Zahlungsvorbereitungsprozess.png}{iref:Zahlungsvorbereitungsprozess}{Zahlungsvorbereitungsprozess}

\paragraphandnewline{Beschreibung des Datenflusses}

\subsubsection{Zubereitungsprozess}
\clearpage
\abbildung{1\textwidth}{img/proc;Zubereitungsprozess.png}{iref:Zubereitungsprozess}{Zubereitungsprozess}

\subsubsection{Abholungsprozess}
\clearpage
\abbildung{1\textwidth}{img/proc;Abholungsprozess.png}{iref:Abholungsprozess}{Abholungsprozess}

\subsubsection{Zahlungsrückabwicklungsprozess}
\clearpage
\abbildung{1\textwidth}{img/proc;Zahlungsrückabwicklungsprozess.png}{iref:Zahlungsrückabwicklungsprozess}{Zahlungsrückabwicklungsprozess}

% =================================
% = Main Process
% =================================
\subsubsection{Verwaltungsprozess zum Speisekarten Editieren}
Der Prozess zum Speisekarten Editieren kann prinzipiell jederzeit gestartet werden. Es gibt keine wirklichen Bedingungen, da die Idee ist, dass der Einstieg sehr einfach ist. Daher soll es möglich sein, dass jeder selbst ohne Account oder Ähnliches direkt in die Erstellung, welche das Editieren umfasst, springen kann. Sollte bereits eine Speisekarte existieren, ist eine Prüfung eines Accounts notwendig.

In Bezug auf Randbedingungen, welche hierbei zu betrachten sind, sind folgende relevant. Der Prozess sollte innerhalb von 24 Stunden abgeschlossen werden, andernfalls wird angenommen, dass kein Interesse mehr besteht. Der Prozess soll dabei auf mehrere Arten enden können, einerseits durch ein Zwischenspeichern der Änderungen oder dem Veröffentlichen der Änderungen, andererseits durch das manuelle Abbrechen, Verwerfen der Änderungen, das der Standardfall wäre, sollte die ''Time To Life'' überschritten werden.

\paragraphandnewline{Beteiligte Prozessrollen}
Die Person, die in diesem Prozess konkret Aufgaben übernehmen kann, ist diejenige, die für die Führung der Speisekarte zuständig ist.

\clearpage
\paragraphandnewline{Visualisierung des Prozessflusses}
\abbildung{1\textwidth}{img/proc;SpeisekartenEditierProzess.png}{iref:Speisekarteneditierprozess}{Speisekarteneditierprozess}

\paragraphandnewline{Detailinformationen zu den Prozessschritten}
Hierbei wird sich an der 


\paragraphandnewline{Beschreibung des Prozesskontexts}
Was passiert mit den Prozessdaten,  Klassendiagramm!

\section{Technologische Umsetzung der Prozesse}
\label{sec:technologie_prozesse}
\subsection{Datenmodell}
\label{sec:datenmodell}
\abbildung{1\textwidth}{img/uml;order_datenmodell.png}{iref:orderDatabase}{Order Datenbank}

\subsection{Architektur}
\abbildung{1\textwidth}{img/uml;Architekturdiagramm}{iref:architekturdiagramm}{Architekturdiagramm}

\subsubsection{Asynchrone Kommunikation durch Queuing Systeme}
\subsubsection{Backend Java Frameworks Quarkus und Springboot}
\subsubsection{Frontend Java Frameworks Vue mit Nuxt}

\section{Ausblick der praktischen Anwendung}
\label{sec:zukunft}

In Zusammenarbeit mit ausgewählten Restaurants soll dieses Software-System im kleineren Kreis getestet und ausgereift werden. Sobald die Kernprozesse über die technische Infrastruktur stabil und praxiserprobt laufen, können nächste Schritte geplant werden. Darunter würden weitere Prozesse und das Herantreten an weitere Restaurants fallen. 

Auch langfristig besteht erhebliches Potenzial für die Digitalisierung der Gastronomie und entsprechend weitere Pläne. Diese umfassen, dass Restaurants nicht manuell einen Account erstellen müssen, sondern automatisch integriert werden. Dabei sollen die Inhalte wie deren Speisekarte, Name und Telefonnummer durch Webscraping ermittelt werden. Sollten genügend Informationen gefunden werden, kann ein Phantomprofil erstellt werden, das mit dem Bestellprozess der Kunden kombiniert werden kann. Der Vorteil besteht darin, dass, wenn eine Bestellung erfolgt, ein \acs{KI}-gestützter Anruf oder Ähnliches an das Restaurant erfolgt, ohne dass es sich registriert hat und der Nutzer mehr machen muss, als das Anklicken der Gerichte, die er will. Ermöglichen kann dies aktuell schon das aktuelle OpenAI-Modell \citep[vgl.][]{openai_introducing_2024}. Somit können Restaurants Online-Bestellungen annehmen, ohne eigene Systeme dafür zu besitzen oder sich überhaupt damit auseinanderzusetzen. Das würde wiederum eine mühelose Skalierung ermöglichen, ohne großen Marketingaufwand. Auch für die Restaurants, die sich später registrieren möchten, ist dies von Nutzen, da sie bereits auf einer soliden Basis aufbauen können, weil möglichst viele Informationen bereits erfasst wurden.

Weitere Möglichkeiten wären eine Art eine gestützte Speisekartengenerierung durch \acs{KI} oder Bestandsmanagement, das automatisch im Überblick hat, wann für welche Gerichte der Bestand ausgeht und entsprechend diese Gerichte von der Speisekarte streicht. Auch eine Art Gründerunterstützung ist zu denken, bei der für neue Gastronomen schon ein Großteil der bürokratischen Hürden abgebaut wird.

Wie die Details allerdings zur aktuellen Implementierung aussehen, konnte leider nicht mehr im Umfang der Hauptarbeit eingebracht werden, daher sind diese Details im Anhang einsehbar.